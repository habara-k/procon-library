snippet dump
    DUMP(${1});${0}

snippet cout
    cout << ${1} << endl;${0}

snippet print
    printf("${1}"${2});${0}

snippet puts
    printf("${1}\n"${2});${0}

snippet endl
    cout << endl;

snippet infty
    numeric_limits<${1:int}>::max()${0}

snippet iota
    iota(${1:a}.begin(), $1.end(), ${2:0});${0}

snippet next_permutation
    next_permutation(${1:a}.begin(), $1.end())${0}


snippet for
    for (int ${1:i} = ${2:0}; $1 < ${3:n}; ++$1) {
        ${0}
    }

snippet fore
    for (int ${1:i} = ${2:0}; $1 <= ${3:n}; ++$1) {
        ${0}
    }

snippet rfor
    for (int ${1:i} = ${2:n}-1; $1 >= ${3:0}; --$1) {
        ${0}
    }

snippet rfore
    for (int ${1:i} = ${2:n}; $1 >= ${3:0}; --$1) {
        ${0}
    }

snippet rep
    for (int ${1:i} = 0; $1 < ${2:n}; ++$1) {
        ${0}
    }

snippet rrep
    for (int ${1:i} = ${2:n}-1; $1 >= 0; --$1) {
        ${0}
    }

snippet All
    ${1:c}.begin(), $1.end()${0}

snippet rAll
    ${1:c}.rbegin(), $1.rend()${0}

snippet sort
    sort(${1:c}.begin(), $1.end()${2:#:,});${0}

snippet rsort
    sort(${1:c}.rbegin(), $1.rend());${0}

snippet fill
    fill(${1:c}.begin(), $1.end(), ${2:x});${0}

snippet each
    for (${1:auto} ${2:e} : ${3:c}) {
        ${0}
    }

snippet lb
    lower_bound(${1:c}.begin(), $1.end(), ${2:x})${0}

snippet ub
    upper_bound(${1:c}.begin(), $1.end(), ${2:x})${0}

snippet count
    upper_bound(${1:c}.begin(), $1.end(), ${2:x}) - lower_bound($1.begin(), $1.end(), $2)${0}

snippet unique
    sort(${1:c}.begin(), $1.end());
    $1.erase(unique($1.begin(), $1.end()), $1.end());

snippet copy
    copy(${1:src}.begin(), $1.end(), ${2:dst}.begin());${0}

snippet exist
    ${1:st}.find(${2:elem}) != $1.end()${0}

snippet sum
    accumulate(${1:c}.begin()${2:#:+a}, $1.end()${3:#:+b}, ${4:0})${0}

snippet max
    *max_element(${1:c}.begin(), $1.end())${0}

snippet min
    *min_element(${1:c}.begin(), $1.end())${0}

snippet priority_queue
    priority_queue<${1:pair<int,int>}>${0}

snippet priority_queue_greater
    priority_queue<${1:pair<int,int>}, vector<$1>, greater<$1>>${0}

snippet make_v
    make_v<${1:int}>(${2:n})${0}

snippet make_vector
    make_vector<${1:int}>(${2:n}, ${3:0})${0}

snippet binary_search
    auto check = [&](${1:int} k) {
        ${2:condition}
    };

    $1 ng = ${3:-1}, ok = ${4:n};
    while (abs(ok - ng) > ${5:1}) {
        $1 mid = (ng + ok) / 2;
        (check(mid) ? ok : ng) = mid;
    }

snippet ternary_search
    auto f = [&](${1:double} x) {
        ${2:function}
    };

    $1 lb = ${3:-1e9}, ub = ${4:1e9};
    while (abs(lb - ub) > ${5:1e-9}) {
        double m1 = (2*lb+ub)/3,
               m2 = (lb+2*ub)/3;

        if (fx(m1) < fx(m2)) lb = m1;
        else ub = m2;
    }

snippet next_combination
    int64_t next_combination(int64_t mask) {
        int64_t x = mask & -mask, y = mask + x;
        return (((mask & ~y) / x) >> 1) | y;
    }

snippet random
    const int SEED = 0;
    std::mt19937 mt(SEED);

snippet clock
    struct Clock {
        clock_t start;
        Clock() : start(clock()) {}
        double operator()() {
            return static_cast<double>(clock() - start) / CLOCKS_PER_SEC;
        }
    };


snippet inversion

    template<typename T>
    int64_t inversion(const vector<T>& A)
    {
        map<T, int> idx;
        for (const T& a : A) idx[a] = -1;

        int cnt = 0;
        for (auto& p : idx) p.second = cnt++;

        assert(cnt == A.size());

        BIT<int> bit(cnt+1);
        int64_t res = 0;
        for (int i = 0; i < A.size(); ++i) {
            res += i - bit.sum(idx[A[i]]);
            bit.add(idx[A[i]], 1);
        }

        return res;
    }


snippet longest_increasing_subsequence

    template<typename T>
    int LIS(const vector<T>& a) {
        int n = a.size();
        T INF = numeric_limits<T>::max();
        vector<T> dp(n, INF);
        for (int i = 0; i < n; ++i) {
            *lower_bound(dp.begin(), dp.end(), a[i]) = a[i];
        }
        return distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));
    }


snippet lazy_segment_tree

    template<typename M, typename OM = M>
    struct LazySegmentTree {
        int sz;
        vector<M> data;
        vector<OM> lazy;
        const M e;
        const OM oe;
        const function<M(M,M)> f;
        const function<M(M,OM,int)> g;
        const function<OM(OM,OM)> h;

        LazySegmentTree(
                int n, const M& e, const OM& oe,
                const function<M(M,M)>& f,
                const function<M(M,OM,int)>& g,
                const function<OM(OM,OM)>& h
                ) : e(e), oe(oe), f(f), g(g), h(h) {
            sz = 1;
            while (sz < n) sz <<= 1;
            data.assign(2*sz, e);
            lazy.assign(2*sz, oe);
        }

        void set(int i, const M &x) {
            data[i + sz] = x;
        }

        void build() {
            for(int i = sz-1; i > 0; --i) {
                data[i] = f(data[2*i], data[2*i+1]);
            }
        }

        void propagate(int k, int len) {
            if (lazy[k] == oe) return;
            if (k < sz) {
                lazy[2*k  ] = h(lazy[2*k  ], lazy[k]);
                lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);
            }
            data[k] = g(data[k], lazy[k], len);
            lazy[k] = oe;
        }

        M update(int a, int b, const OM &x, int k, int l, int r) {
            propagate(k, r - l);
            if (r <= a || b <= l) {
                return data[k];
            } else if (a <= l && r <= b) {
                lazy[k] = h(lazy[k], x);
                propagate(k, r - l);
                return data[k];
            } else {
                return data[k] = f(
                    update(a, b, x, 2*k,   l, (l+r)/2),
                    update(a, b, x, 2*k+1, (l+r)/2, r));
            }
        }

        void update(int a, int b, const OM &x) {
            // update [a, b) with x.
            update(a, b, x, 1, 0, sz);
        }

        M query(int a, int b, int k, int l, int r) {
            propagate(k, r - l);
            if (r <= a || b <= l) {
                return e;
            } else if (a <= l && r <= b) {
                return data[k];
            } else {
                return f(
                    query(a, b, 2*k,   l, (l+r)/2),
                    query(a, b, 2*k+1, (l+r)/2, r));
            }
        }

        M query(int a, int b) {
            // return f[a, b).
            return query(a, b, 1, 0, sz);
        }
    };


snippet union_find

    struct UnionFind
    {
        vector<int> par, sz;
        UnionFind(int n) : par(n), sz(n, 1) {
            for (int i = 0; i < n; ++i) par[i] = i;
        }

        int root(int x) {
            if (par[x] == x) return x;
            return par[x] = root(par[x]);
        }

        void merge(int x, int y) {
            x = root(x);
            y = root(y);
            if (x == y) return;
            if (sz[x] < sz[y]) swap(x, y);
            par[y] = x;
            sz[x] += sz[y];
            sz[y] = 0;
        }

        bool issame(int x, int y) {
            return root(x) == root(y);
        }

        int size(int x) {
            return sz[root(x)];
        }
    };


snippet weighted_union_find

    template<typename A>
    struct WeightedUnionFind
    {
        vector<int> par, sz;
        vector<A> data;     // data[x]: diff from root to x
        WeightedUnionFind(int n, A e=0) :
            par(n), sz(n, 1), data(n, e) {
            for (int i = 0; i < n; ++i) par[i] = i;
        }

        int root(int x) {
            if (par[x] == x) return x;
            int r = root(par[x]);
            data[x] += data[par[x]];
            return par[x] = r;
        }

        A weight(int x) {
            root(x);
            return data[x];
        }

        A diff(int x, int y) {
            // diff from x to y
            return data[y] - data[x];
        }

        void merge(int x, int y, A w) {
            // merge so that "diff from x to y" will be w.
            w += weight(x); w -= weight(y);
            x = root(x); y = root(y);
            if (x == y) return;
            if (sz[x] < sz[y]) swap(x, y), w = -w;
            par[y] = x;
            sz[x] += sz[y];
            sz[y] = 0;
            data[y] = w;
        }

        bool issame(int x, int y) {
            return root(x) == root(y);
        }
    };


snippet binary_indexed_tree

    template<typename T>
    struct BIT {
        vector<T> bit;
        int sz;

        BIT(int n) : sz(n+1), bit(n+1) {}

        void add(int i, T x) {
            i += 1;
            while (i < sz) { bit[i] += x; i += i & -i; }
        }

        T sum(int i) {
            i += 1; T s = 0;
            while (i > 0) { s += bit[i]; i -= i & -i; }
            return s;
        }
    };


snippet segment_tree

    template<typename M>
    struct SegmentTree {
        int sz;
        vector<M> data;
        const M e;
        const function<M(M,M)> f;

        SegmentTree(
                int n, const M& e,
                const function<M(M,M)>& f
                ) : e(e), f(f) {
            sz = 1;
            while (sz < n) sz <<= 1;
            data.assign(2*sz, e);
        }

        void update(int k, const M &x) {
            k += sz;
            data[k] = x;
            while (k >>= 1) {
                data[k] = f(data[2*k], data[2*k+1]);
            }
        }

        M query(int a, int b, int k, int l, int r) {
            if (r <= a || b <= l) {
                return e;
            } else if (a <= l && r <= b) {
                return data[k];
            } else {
                return f(query(a,b,2*k,  l,(l+r)/2),
                         query(a,b,2*k+1,(l+r)/2,r));
            }
        }

        M query(int a, int b) {
            // return f[a,b)
            return query(a, b, 1, 0, sz);
        }

        M operator[](int k) {
            return data[k + sz];
        }
    };


snippet rolling_hash

    struct RollingHash {
        const int base = 9973;
        const int mod[2] = {999999937, 1000000007};
        vector<int> s;
        vector<int64_t> hash[2], pow[2];

        RollingHash(const vector<int> &cs) : s(cs) {
            int n = s.size();
            for (int id = 0; id < 2; ++id) {
                hash[id].assign(n+1, 0);
                pow[id].assign(n+1, 1);
                for (int i = 0; i < n; ++i) {
                    hash[id][i+1] = (hash[id][i] * base + s[i]) % mod[id];
                    pow[id][i+1] = pow[id][i] * base % mod[id];
                }
            }
        }

        // get hash of s[l:r)
        int64_t get(int l, int r, int id = 0) {
            int64_t res = hash[id][r] - hash[id][l] * pow[id][r-l] % mod[id];
            if (res < 0) res += mod[id];
            return res;
        }
    };


snippet prime_factorize

    // O(sqrt(n))
    map<int64_t, int> prime_factorize(int64_t n) {
        map<int64_t, int> ret;
        for (int64_t i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                ret[i]++;
                n /= i;
            }
        }
        if (n != 1) ret[n] = 1;
        return ret;
    }


snippet combination

    template<typename Field>
    struct Combination {
        vector<Field> _fact, _rfact, _inv;

        Combination(int n) : _fact(n), _rfact(n), _inv(n) {
            _fact[0] = _rfact[n-1] = 1;
            for (int i = 1; i < n; ++i) _fact[i] = _fact[i-1] * i;
            _rfact[n-1] /= _fact[n-1];
            for (int i = n-1; i > 0; --i) _rfact[i-1] = _rfact[i] * i;
            for (int i = 1; i < n; ++i) _inv[i] = _rfact[i] * _fact[i-1];
        }

        inline Field fact(int k) const { return _fact.at(k); }

        inline Field rfact(int k) const { return _rfact.at(k); }

        inline Field inv(int k) const { assert(k != 0); return _inv.at(k); }

        Field P(int n, int r) const {
            if (r < 0 || n < r) return 0;
            return fact(n) * rfact(n-r);
        }

        Field C(int n, int r) const {
            if (r < 0 || n < r) return 0;
            return fact(n) * rfact(r) * rfact(n-r);
        }

        Field H (int n, int r) const {
            return (n == 0 && r == 0) ? 1 : C(n+r-1, r);
        }
    };


snippet fast_mobius_transform

    template<typename T>
    vector<T> fast_mobius_transform_1(const vector<T>& g) {
        // Return f(s):
        // s.t. g(s) = \sum_{s \subset t} f(t)
        // ( e.g. f(s) = \sum_{s \subset t} (-1)^|t-s| * g(t) )
        int n = g.size();
        vector<T> f = g;
        for (int i = 0; (1 << i) < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (!(j >> i & 1)) {
                    f[j] -= f[j | (1<<i)];
                }
            }
        }
        return f;
    }

    template<typename T>
    vector<T> fast_mobius_transform_2(const vector<T>& g) {
        // Return f(s):
        // s.t. g(s) = \sum_{t \subset s} f(t)
        // ( e.g. f(s) = \sum_{t \subset s} (-1)^|t-s| * g(t) )
        int n = g.size();
        vector<T> f = g;
        for (int i = 0; (1 << i) < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (j >> i & 1) {
                    f[j] -= f[j & ~(1<<i)];
                }
            }
        }
        return f;
    }


snippet matrix

    template<typename T>
    struct Matrix {
        vector<vector<T>> A;

        Matrix() {}

        Matrix(size_t n, size_t m) : A(n, vector<T>(m)) {}

        Matrix(size_t n) : A(n, vector<T>(n)) {};

        size_t height() const {
            return (A.size());
        }

        size_t width() const {
            return (A[0].size());
        }

        inline const vector<T> &operator[](int k) const {
            return (A.at(k));
        }

        inline vector<T> &operator[](int k) {
            return (A.at(k));
        }

        static Matrix I(size_t n) {
            Matrix B(n);
            for (int i = 0; i < n; i++) B[i][i] = 1;
            return (B);
        }

        Matrix operator-() const {
            size_t n = height(), m = width();
            Matrix B = *this;
            for (int i = 0; i < n; ++i)
                for (int j = 0; j < m; ++j)
                    B[i][j] = -B[i][j];
            return (B);
        }

        Matrix& operator+=(const Matrix& B) {
            size_t n = height(), m = width();
            assert(n == B.height() && m == B.width());
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    A[i][j] += B[i][j];
            return (*this);
        }

        Matrix& operator-=(const Matrix& B) {
            return (*this += -B);
        }

        Matrix& operator*=(const Matrix& B) {
            size_t n = height(), m = B.width(), p = width();
            assert(p == B.height());
            Matrix C(n, m);
            for(int i = 0; i < n; i++)
                for(int j = 0; j < m; j++)
                    for(int k = 0; k < p; k++)
                        C[i][j] += A[i][k] * B[k][j];
            A.swap(C.A);
            return (*this);
        }

        Matrix pow(int64_t k) {
            Matrix B = Matrix::I(height()), tmp = *this;
            while (k > 0) {
                if (k & 1) B *= tmp;
                tmp *= tmp;
                k >>= 1LL;
            }
            return (B);
        }

        const Matrix operator+(const Matrix& B) const {
            return (Matrix(*this) += B);
        }

        const Matrix operator-(const Matrix& B) const {
            return (Matrix(*this) -= B);
        }

        const Matrix operator*(const Matrix& B) const {
            return (Matrix(*this) *= B);
        }

        int GaussJordanElimination() {
            int rank = 0;
            for (int col = 0; col < width(); ++col) {
                int pivot = -1;
                for (int row = rank; row < height(); ++row) {
                    if (A[row][col] != 0) {
                        pivot = row;
                        break;
                    }
                }
                if (pivot == -1) continue;
                swap(A[rank], A[pivot]);
                T topLeft = A[rank][col];
                for (int c = col; c < width(); ++c) {
                    A[rank][c] /= topLeft;
                }
                for (int row = rank+1; row < height(); ++row) {
                    T ratio = A[row][col];
                    for (int c = col; c < width(); ++c)
                        A[row][c] -= ratio * A[rank][c];
                }
                ++rank;
            }
            return (rank);
        }

        friend istream& operator>>(istream& is, Matrix& B) {
            is >> B.A;
            return (is);
        }

        friend ostream& operator<<(ostream& os, Matrix& B) {
            size_t n = B.height(), m = B.width();
            for(int i = 0; i < n; i++) {
                os << (i == 0 ? "[" : " ");
                for(int j = 0; j < m; j++) {
                    os << B[i][j] << (j == m-1 ? "]" : ",");
                }
                os << (i == n-1 ? "]\n" : ",\n");
            }
            return (os);
        }
    };


snippet prime_table

    // O(nloglogn)
    vector<bool> prime_table(int n) {
        n = max(n, 1);
        vector<bool> prime(n+1, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i * i <= n; i++) {
            if (!prime[i]) continue;
            for (int j = 2 * i; j <= n; j += i) {
                prime[j] = false;
            }
        }
        return prime;
    }


snippet modint

    template<int64_t mod>
    struct modint {
        using LL = int64_t;
        LL val;
        modint(LL val=0) : val(((val % mod) + mod) % mod) {}

        const modint operator+() const { return *this; }
        const modint operator-() const { return (-val + mod) % mod; }
        const modint inv() const { return pow(mod-2); }

        modint& operator+=(const modint& rhs) {
            (val += rhs.val) %= mod;
            return *this;
        }
        modint& operator-=(const modint& rhs) {
            return *this += -rhs;
        }
        modint& operator*=(const modint& rhs) {
            (val *= rhs.val) %= mod;
            return *this;
        }
        modint& operator/=(const modint& rhs) {
            return *this *= rhs.inv();
        }

        const modint operator+(const modint& rhs) const {
            return modint(*this) += rhs;
        }
        const modint operator-(const modint& rhs) const {
            return modint(*this) -= rhs;
        }
        const modint operator*(const modint& rhs) const {
            return modint(*this) *= rhs;
        }
        const modint operator/(const modint& rhs) const {
            return modint(*this) /= rhs;
        }

        const modint pow(LL n) const {
            modint ret = 1, tmp = val;
            while (n > 0) {
                if (n & 1) ret *= tmp;
                tmp *= tmp; n >>= 1;
            }
            return ret;
        }

        bool operator==(const modint& rhs) const { return val == rhs.val; }
        bool operator!=(const modint& rhs) const { return !(*this == rhs); }

        friend const modint operator+(const LL& lhs, const modint& rhs) {
            return modint(lhs) + rhs;
        }
        friend const modint operator-(const LL& lhs, const modint& rhs) {
            return modint(lhs) - rhs;
        }
        friend const modint operator*(const LL& lhs, const modint& rhs) {
            return modint(lhs) * rhs;
        }
        friend const modint operator/(const LL& lhs, const modint& rhs) {
            return modint(lhs) / rhs;
        }

        friend bool operator==(const LL& lhs, const modint& rhs) {
            return modint(lhs) == rhs;
        }
        friend bool operator!=(const LL& lhs, const modint& rhs) {
            return modint(lhs) != rhs;
        }

        friend ostream& operator<<(ostream& os, const modint& a) {
            return os << a.val;
        }
        friend istream& operator>>(istream& is, modint& a) {
            LL tmp; is >> tmp;
            a = tmp;
            return is;
        }
    };


snippet bell

    // Bell 数
    // Bell(n, k) := 区別できるn 個のボールを,
    //               区別できないk 個の箱に入れる場合の数
    template<typename Field>
    Field Bell(int64_t n, int k) {
        Field ret = 0;
        for (int i = 0; i <= k; ++i) {
            ret += Stirling<Field>(n, i);
        }
        return ret;
    }


snippet fast_zeta_transform

    template<typename T>
    vector<T> fast_zeta_transform_1(const vector<T>& f) {
        // Return g(s):
        // s.t. g(s) = \sum_{s \subset t} f(t)
        int n = f.size();
        vector<T> g = f;
        for (int i = 0; (1 << i) < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (!(j >> i & 1)) {
                    g[j] += g[j | (1<<i)];
                }
            }
        }
        return g;
    }

    template<typename T>
    vector<T> fast_zeta_transform_2(const vector<T>& f) {
        // Return g(s):
        // s.t. g(s) = \sum_{t \subset s} f(t)
        int n = f.size();
        vector<T> g = f;
        for (int i = 0; (1 << i) < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (j >> i & 1) {
                    g[j] += g[j & ~(1<<i)];
                }
            }
        }
        return g;
    }


snippet stirling

    // スターリング数
    // Stirling(n, k) := 区別できるn 個のボールを
    //                   区別できないk 個の箱に入れる場合の数
    //                   (ただし空箱はNG)
    template<typename Field>
    Field Stirling(int64_t n, int k) {
        Combination<Field> comb(k+1);

        Field ret = 0;
        for (int i = 0; i <= k; ++i) {
            ret += comb.C(k, i) * Field{k-i}.pow(n) * (i & 1 ? -1 : 1);
        }
        return ret /= comb.fact(k);
    }


snippet extended_gcd

    template<typename T>
    T extended_gcd(T a, T b, T& x, T& y) {
        // solve ax + by = gcd(a, b)
        if (b == 0) { x = 1; y = 0; return a; }

        T X, Y;
        T g = extended_gcd(b, a % b, X, Y);
        x = Y; y = X - a/b * Y;
        return g;
    }


snippet is_prime

    // O(sqrt(n))
    bool is_prime(int64_t n) {
        assert(n > 0);
        if (n == 1) return false;
        for (int64_t i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }


snippet partition

    // 分割数
    // Partition(k, n) := 区別できないn 個のボールを
    //                    区別できないk 個の箱に入れる場合の数
    template<typename Ring>
    Ring Partition(int k, int n) {
        vector<vector<Ring>> part(k+1, vector<Ring>(n+1));
        part[0][0] = 1;
        for (int i = 1; i <= k; ++i) {
            for (int j = 0; j <= n; ++j) {
                if (j-i >= 0) {
                    part[i][j] = part[i-1][j] + part[i][j-i];
                } else {
                    part[i][j] = part[i-1][j];
                }
            }
        }
        return part[k][n];
    }


snippet lowest_common_ancestor

    struct LCA {
        int n, log2_n;
        vector<int> depth;
        vector<vector<int>> par;

        void dfs(const vector<vector<int>>& G, int v, int p, int d) {
            depth[v] = d;
            par[0][v] = p;
            for (auto to : G[v]) {
                if (to != p) dfs(G, to, v, d+1);
            }
        }

        LCA(const vector<vector<int>>& G, int root=0) :
                n(G.size()), log2_n(log2(n)), depth(n),
                par(log2_n+1, vector<int>(n,-1)) {

            dfs(G, root, -1, 0);
            for (int k = 0; k < log2_n; ++k) {
                for (int v = 0; v < n; ++v) {
                    if (par[k][v] != -1) {
                        par[k+1][v] = par[k][par[k][v]];
                    }
                }
            }
        }

        int query(int u, int v) {
            if (depth[u] > depth[v]) swap(u, v);

            // align the depth of u and v
            for (int k = 0; k <= log2_n; ++k) {
                if ((depth[v] - depth[u]) >> k & 1) {
                    v = par[k][v];
                }
            }
            if (u == v) return u;

            // go back until u and v's parents do not match
            for (int k = log2_n; k >= 0; --k) {
                if (par[k][u] != par[k][v]) {
                    u = par[k][u];
                    v = par[k][v];
                }
            }
            return par[0][u];
        }
    };


snippet topological_sort

    vector<int> topological_sort(const vector<vector<int>>& G)
    {
        int n = G.size();
        vector<int> num(n), ord;
        for (int i = 0; i < n; ++i) {
            for (int u : G[i]) ++num[u];
        }
        stack<int> st;
        for(int i = 0; i < n; ++i) {
            if (num[i] == 0) st.push(i);
        }
        while (!st.empty()) {
            int i = st.top(); st.pop();
            ord.push_back(i);
            for (int u : G[i]) {
                --num[u];
                if (num[u] == 0) st.push(u);
            }
        }
        return ord;
    }


snippet kruskal

    template<typename T>
    T kruskal(const vector<edge<T>> &es, int V) {

        UnionFind uf(V);
        T ret = 0;

        vector<int> ord(es.size());
        iota(ord.begin(), ord.end(), 0);
        sort(ord.begin(), ord.end(), [&](int i,int j){
                return es[i].cost < es[j].cost;
                });

        for (auto i : ord) {
            auto &e = es[i];
            if (!uf.issame(e.src, e.to)) {
                ret += e.cost;
                uf.merge(e.src, e.to);
            }
        }

        return ret;
    }


snippet dinic

    template<typename T>
    struct Dinic {
        const T INF;

        struct edge {
            int to;
            T cap;
            int rev;
            bool isrev;
        };

        vector<vector<edge>> g;
        vector<int> level, iter;

        Dinic(int V) : INF(numeric_limits<T>::max()), g(V) {}

        void add_edge(int src, int to, T cap) {
            g[src].push_back({to, cap, (int)g[to].size(), false});
            g[to].push_back({src, 0, (int)g[src].size()-1, true});
        }

        bool bfs(int s, int t) {
            level.assign(g.size(), -1);
            queue<int> que;
            level[s] = 0;
            que.push(s);
            while (!que.empty()) {
                int v = que.front();
                que.pop();
                for (auto &e : g[v]) {
                    if (e.cap > 0 && level[e.to] == -1) {
                        level[e.to] = level[v] + 1;
                        que.push(e.to);
                    }
                }
            }
            return level[t] != -1;
        }

        T dfs(int v, const int t, T flow) {
            if (v == t) return flow;
            for (int &i = iter[v]; i < g[v].size(); i++) {
                edge &e = g[v][i];
                if (e.cap > 0 && level[v] < level[e.to]) {
                    T d = dfs(e.to, t, min(flow, e.cap));
                    if (d > 0) {
                        e.cap -= d;
                        g[e.to][e.rev].cap += d;
                        return d;
                    }
                }
            }
            return 0;
        }

        T max_flow(int s, int t) {
            T flow = 0;
            while (bfs(s, t)) {
                iter.assign(g.size(), 0);
                T f = 0;
                while((f = dfs(s, t, INF)) > 0) flow += f;
            }
            return flow;
        }
    };


snippet dijkstra

    template<typename T>
    vector<T> dijkstra(const vector<vector<edge<T>>> &g, int s) {
        const T INF = numeric_limits<T>::max();
        vector<T> d(g.size(), INF);

        using Pi = pair<T, int>;
        priority_queue<Pi, vector<Pi>, greater<Pi>> que;
        d[s] = 0;
        que.emplace(d[s], s);
        while (!que.empty()) {
            T cost;
            int v;
            tie(cost, v) = que.top();
            que.pop();
            if (d[v] < cost) continue;
            for (auto &e : g[v]) {
                T nxt = cost + e.cost;
                if (d[e.to] > nxt) {
                    d[e.to] = nxt;
                    que.emplace(nxt, e.to);
                }
            }
        }
        return d;
    }


snippet warshall_floyd

    template<typename T>
    void warshall_floyd(vector<vector<T>> &g) {
        const auto INF = numeric_limits<T>::max();
        int n = g.size();
        for(int k = 0; k < n; k++) {
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    if(g[i][k] == INF || g[k][j] == INF) continue;
                    g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }
    }


snippet strongly_connected_components

    struct StronglyConnectedComponents {
        vector<vector<int>> g, rg, t;
        vector<int> comp, ord, used;

        StronglyConnectedComponents(const vector<vector<int>>& g) :
            g(g), rg(g.size()), comp(g.size(), -1), used(g.size())
        {
            for (int i = 0; i < g.size(); i++) {
                for (int to : g[i]) {
                    rg[to].push_back(i);
                }
            }
        }

        void dfs(int idx) {
            if (used[idx]) return;
            used[idx] = true;
            for (int to : g[idx]) dfs(to);
            ord.push_back(idx);
        }

        void rdfs(int idx, int cnt) {
            if (comp[idx] != -1) return;
            comp[idx] = cnt;
            for (int to : rg[idx]) rdfs(to, cnt);
        }

        void build() {
            for (int i = 0; i < g.size(); i++) dfs(i);
            reverse(ord.begin(), ord.end());
            int ptr = 0;
            for (int i : ord) if (comp[i] == -1) rdfs(i, ptr), ptr++;

            t.resize(ptr);
            for (int i = 0; i < g.size(); i++) {
                for (int to : g[i]) {
                    int x = comp[i], y = comp[to];
                    if (x == y) continue;
                    t[x].push_back(y);
                }
            }
        }
    };
