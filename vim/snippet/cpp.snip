snippet dump
    DUMP(${1});${0}

snippet cout
    cout << ${1} << endl;${0}

snippet printf
    printf("${1}"${2});${0}

snippet puts
    printf("${1}\n"${2});${0}

snippet space
    putchar(' ');${0}
snippet endl
    putchar('\n');${0}

snippet infty
    numeric_limits<${1:int}>::max()${0}

snippet iota
    iota(${1:a}.begin(), $1.end(), ${2:0});${0}

snippet next_permutation
    next_permutation(${1:a}.begin(), $1.end())${0}


snippet for
    for (int ${1:i} = ${2:0}; $1 < ${3:n}; ++$1) {
        ${0}
    }

snippet fore
    for (int ${1:i} = ${2:0}; $1 <= ${3:n}; ++$1) {
        ${0}
    }

snippet rfor
    for (int ${1:i} = ${2:n}-1; $1 >= ${3:0}; --$1) {
        ${0}
    }

snippet rfore
    for (int ${1:i} = ${2:n}; $1 >= ${3:0}; --$1) {
        ${0}
    }

snippet rep
    for (int ${1:i} = 0; $1 < ${2:n}; ++$1) {
        ${0}
    }

snippet rrep
    for (int ${1:i} = ${2:n}-1; $1 >= 0; --$1) {
        ${0}
    }

snippet All
    ${1:c}.begin(), $1.end()${0}

snippet rAll
    ${1:c}.rbegin(), $1.rend()${0}

snippet sort
    sort(${1:c}.begin(), $1.end()${2:#:,});${0}

snippet rsort
    sort(${1:c}.rbegin(), $1.rend());${0}

snippet fill
    fill(${1:c}.begin(), $1.end(), ${2:x});${0}

snippet each
    for (${1:auto} ${2:e} : ${3:c}) {
        ${0}
    }

snippet lb
    lower_bound(${1:c}.begin(), $1.end(), ${2:x})${0}

snippet ub
    upper_bound(${1:c}.begin(), $1.end(), ${2:x})${0}

snippet count
    upper_bound(${1:c}.begin(), $1.end(), ${2:x}) - lower_bound($1.begin(), $1.end(), $2)${0}

snippet unique
    sort(${1:c}.begin(), $1.end());
    $1.erase(unique($1.begin(), $1.end()), $1.end());

snippet copy
    copy(${1:src}.begin(), $1.end(), ${2:dst}.begin());${0}

snippet exist
    ${1:st}.find(${2:elem}) != $1.end()${0}

snippet sum
    accumulate(${1:c}.begin()${2:#:+a}, $1.end()${3:#:+b}, ${4:0})${0}

snippet max
    *max_element(${1:c}.begin(), $1.end())${0}

snippet min
    *min_element(${1:c}.begin(), $1.end())${0}

snippet priority_queue
    priority_queue<${1:pair<int,int>}>${0}

snippet priority_queue_greater
    priority_queue<${1:pair<int,int>}, vector<$1>, greater<$1>>${0}

snippet make_v
    make_v<${1:int}>(${2:n})${0}

snippet make_vector
    make_vector<${1:int}>(${2:n}, ${3:0})${0}

snippet binary_search
    auto check = [&](${1:int} k) {
        ${2:condition}
    };

    $1 ng = ${3:-1}, ok = ${4:n};
    while (abs(ok - ng) > 1) {
        $1 mid = (ng + ok) / 2;
        (check(mid) ? ok : ng) = mid;
    }

snippet next_combination
    LL next_combination(LL mask) {
        LL x = mask & -mask, y = mask + x;
        return (((mask & ~y) / x) >> 1) | y;
    }

snippet random
    const int SEED = 0;
    std::mt19937 mt(SEED);

snippet clock
    struct Clock {
        clock_t start;
        Clock() : start(clock()) {}
        double operator()() {
            return static_cast<double>(clock() - start) / CLOCKS_PER_SEC;
        }
    };


snippet inversion

    template<typename T>
    LL inversion(const vector<T>& A)
    {
        map<T, int> idx;
        for (const T& a : A) idx[a] = -1;

        int cnt = 0;
        for (auto& p : idx) p.second = cnt++;

        assert(cnt == A.size());

        BIT<int> bit(cnt+1);
        LL res = 0;
        for (int i = 0; i < A.size(); ++i) {
            res += i - bit.sum(idx[A[i]]);
            bit.add(idx[A[i]], 1);
        }

        return res;
    }


snippet longest_increasing_subsequence

    template<typename T>
    int LIS(const vector<T>& a) {
        int n = a.size();
        T INF = numeric_limits<T>::max();
        vector<T> dp(n, INF);
        for (int i = 0; i < n; ++i) {
            *lower_bound(dp.begin(), dp.end(), a[i]) = a[i];
        }
        return distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));
    }


snippet lazy_segment_tree

    template<typename M, typename OM = M>
    struct LazySegmentTree {
        int sz;
        vector<M> data;
        vector<OM> lazy;
        const M e;
        const OM oe;
        const function<M(M,M)> f;
        const function<M(M,OM,int)> g;
        const function<OM(OM,OM)> h;

        LazySegmentTree(
                int n, const M& e, const OM& oe,
                const function<M(M,M)>& f,
                const function<M(M,OM,int)>& g,
                const function<OM(OM,OM)>& h
                ) : e(e), oe(oe), f(f), g(g), h(h) {
            sz = 1;
            while (sz < n) sz <<= 1;
            data.assign(2*sz, e);
            lazy.assign(2*sz, oe);
        }

        void set(int i, const M &x) {
            data[i + sz] = x;
        }

        void build() {
            for(int i = sz-1; i > 0; --i) {
                data[i] = f(data[2*i], data[2*i+1]);
            }
        }

        void propagate(int k, int len) {
            if (lazy[k] == oe) return;
            if (k < sz) {
                lazy[2*k  ] = h(lazy[2*k  ], lazy[k]);
                lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);
            }
            data[k] = g(data[k], lazy[k], len);
            lazy[k] = oe;
        }

        M update(int a, int b, const OM &x, int k, int l, int r) {
            propagate(k, r - l);
            if (r <= a || b <= l) {
                return data[k];
            } else if (a <= l && r <= b) {
                lazy[k] = h(lazy[k], x);
                propagate(k, r - l);
                return data[k];
            } else {
                return data[k] = f(
                    update(a, b, x, 2*k,   l, (l+r)/2),
                    update(a, b, x, 2*k+1, (l+r)/2, r));
            }
        }

        void update(int a, int b, const OM &x) {
            // update [a, b) with x.
            update(a, b, x, 1, 0, sz);
        }

        M query(int a, int b, int k, int l, int r) {
            propagate(k, r - l);
            if (r <= a || b <= l) {
                return e;
            } else if (a <= l && r <= b) {
                return data[k];
            } else {
                return f(
                    query(a, b, 2*k,   l, (l+r)/2),
                    query(a, b, 2*k+1, (l+r)/2, r));
            }
        }

        M query(int a, int b) {
            // return f[a, b).
            return query(a, b, 1, 0, sz);
        }
    };


snippet union_find

    struct UnionFind
    {
        vector<int> par, sz;
        UnionFind(int n) : par(n), sz(n, 1) {
            for (int i = 0; i < n; ++i) par[i] = i;
        }

        int root(int x) {
            if (par[x] == x) return x;
            return par[x] = root(par[x]);
        }

        void merge(int x, int y) {
            x = root(x);
            y = root(y);
            if (x == y) return;
            if (sz[x] < sz[y]) swap(x, y);
            par[y] = x;
            sz[x] += sz[y];
            sz[y] = 0;
        }

        bool issame(int x, int y) {
            return root(x) == root(y);
        }

        int size(int x) {
            return sz[root(x)];
        }
    };


snippet weighted_union_find

    template<typename A>
    struct WeightedUnionFind
    {
        vector<int> par, sz;
        vector<A> data;     // data[x]: diff from root to x
        WeightedUnionFind(int n, A e=0) :
            par(n), sz(n, 1), data(n, e) {
            for (int i = 0; i < n; ++i) par[i] = i;
        }

        int root(int x) {
            if (par[x] == x) return x;
            int r = root(par[x]);
            data[x] += data[par[x]];
            return par[x] = r;
        }

        A weight(int x) {
            root(x);
            return data[x];
        }

        A diff(int x, int y) {
            // diff from x to y
            return data[y] - data[x];
        }

        void merge(int x, int y, A w) {
            // merge so that "diff from x to y" will be w.
            w += weight(x); w -= weight(y);
            x = root(x); y = root(y);
            if (x == y) return;
            if (sz[x] < sz[y]) swap(x, y), w = -w;
            par[y] = x;
            sz[x] += sz[y];
            sz[y] = 0;
            data[y] = w;
        }

        bool issame(int x, int y) {
            return root(x) == root(y);
        }
    };


snippet binary_indexed_tree

    template<typename T>
    struct BIT {
        vector<T> bit;
        int sz;

        BIT(int n) : sz(n+1), bit(n+1) {}

        void add(int i, T x) {
            i += 1;
            while (i < sz) { bit[i] += x; i += i & -i; }
        }

        T sum(int i) {
            i += 1; T s = 0;
            while (i > 0) { s += bit[i]; i -= i & -i; }
            return s;
        }
    };


snippet segment_tree

    template<typename M>
    struct SegmentTree {
        int sz;
        vector<M> data;
        const M e;
        const function<M(M,M)> f;

        SegmentTree(
                int n, const M& e,
                const function<M(M,M)>& f
                ) : e(e), f(f) {
            sz = 1;
            while (sz < n) sz <<= 1;
            data.assign(2*sz, e);
        }

        void update(int k, const M &x) {
            k += sz;
            data[k] = x;
            while (k >>= 1) {
                data[k] = f(data[2*k], data[2*k+1]);
            }
        }

        M query(int a, int b, int k, int l, int r) {
            if (r <= a || b <= l) {
                return e;
            } else if (a <= l && r <= b) {
                return data[k];
            } else {
                return f(query(a,b,2*k,  l,(l+r)/2),
                         query(a,b,2*k+1,(l+r)/2,r));
            }
        }

        M query(int a, int b) {
            // return f[a,b)
            return query(a, b, 1, 0, sz);
        }

        M operator[](int k) {
            return data[k + sz];
        }
    };


snippet rolling_hash

    struct RollingHash {
        const int base = 9973;
        const int mod[2] = {999999937, 1000000007};
        vector<int> s;
        vector<LL> hash[2], pow[2];

        RollingHash(const vector<int> &cs) : s(cs) {
            int n = s.size();
            for (int id = 0; id < 2; ++id) {
                hash[id].assign(n+1, 0);
                pow[id].assign(n+1, 1);
                for (int i = 0; i < n; ++i) {
                    hash[id][i+1] = (hash[id][i] * base + s[i]) % mod[id];
                    pow[id][i+1] = pow[id][i] * base % mod[id];
                }
            }
        }

        // get hash of s[l:r)
        LL get(int l, int r, int id = 0) {
            LL res = hash[id][r] - hash[id][l] * pow[id][r-l] % mod[id];
            if (res < 0) res += mod[id];
            return res;
        }
    };


snippet combination

    template<typename Field>
    struct Comb {
        Fact<Field> fact;

        Comb(int n) : fact(n) {}

        Field operator()(int n, int r) {
            if (n < 0 || n-r < 0 || r < 0) {
                return Field{0};
            }
            return fact[n] / (fact[n-r] * fact[r]);
        }
    };


snippet factorial

    template<typename Ring>
    struct Fact {

        vector<Ring> fact;

        Fact(int n) {
            fact.resize(n+1);
            fact[0] = Ring{1};
            for (int i = 1; i <= n; ++i) {
                fact[i] = fact[i-1] * Ring{i};
            }
        }

        Ring operator[](int i) {
            return fact[i];
        }
    };


snippet modint

    template<LL mod>
    struct modint {
        LL val;
        modint(LL val=0) : val(((val % mod) + mod) % mod) {}

        const modint operator+() const { return *this; }
        const modint operator-() const { return (-val + mod) % mod; }
        const modint inv() const { return pow(mod-2); }

        modint& operator+=(const modint& rhs) {
            (val += rhs.val) %= mod;
            return *this;
        }
        modint& operator-=(const modint& rhs) {
            return *this += -rhs;
        }
        modint& operator*=(const modint& rhs) {
            (val *= rhs.val) %= mod;
            return *this;
        }
        modint& operator/=(const modint& rhs) {
            return *this *= rhs.inv();
        }

        const modint operator+(const modint& rhs) const {
            return modint(*this) += rhs;
        }
        const modint operator-(const modint& rhs) const {
            return modint(*this) -= rhs;
        }
        const modint operator*(const modint& rhs) const {
            return modint(*this) *= rhs;
        }
        const modint operator/(const modint& rhs) const {
            return modint(*this) /= rhs;
        }

        const modint pow(LL n) const {
            modint ret = 1, tmp = val;
            while (n > 0) {
                if (n & 1) ret *= tmp;
                tmp *= tmp; n >>= 1;
            }
            return ret;
        }

        bool operator==(const modint& rhs) const { return val == rhs.val; }
        bool operator!=(const modint& rhs) const { return !(*this == rhs); }

        friend const modint operator+(const LL& lhs, const modint& rhs) {
            return modint(lhs) + rhs;
        }
        friend const modint operator-(const LL& lhs, const modint& rhs) {
            return modint(lhs) - rhs;
        }
        friend const modint operator*(const LL& lhs, const modint& rhs) {
            return modint(lhs) * rhs;
        }
        friend const modint operator/(const LL& lhs, const modint& rhs) {
            return modint(lhs) / rhs;
        }

        friend bool operator==(const LL& lhs, const modint& rhs) {
            return modint(lhs) == rhs;
        }
        friend bool operator!=(const LL& lhs, const modint& rhs) {
            return modint(lhs) != rhs;
        }

        friend ostream& operator<<(ostream& os, const modint& a) {
            return os << a.val;
        }
        friend istream& operator>>(istream& is, modint& a) {
            LL tmp; is >> tmp;
            a = tmp;
            return is;
        }
    };


snippet bell

    // Bell number
    // Bell(n, k) := the number of cases
    //            to split n balls(distinguished)
    //            into k boxes(not distinguished)
    //
    // require Comb<Field> GREATER THAN OR EQUAL TO k
    template<typename Field>
    Field Bell(LL n, LL k, Comb<Field>& comb) {
        Field ret = 0;
        for (LL l = 0; l <= k; ++l) {
            ret += Stirling(n, l, comb);
        }
        return ret;
    }


snippet stirling

    // Stirling number
    // Stirling(n, k) := the number of cases
    //            to split n balls(distinguished)
    //            into k boxes(not distinguished)
    //            s.t. each box contains at least one ball.
    //
    // require Comb<Field> GREATER THAN OR EQUAL TO k
    template<typename Field>
    Field Stirling(LL n, LL k, Comb<Field>& comb) {
        Field ret = 0;
        for (LL l = 0; l <= k; ++l) {
            ret += comb(k, l) * Field(k-l).pow(n) * (l & 1 ? -1 : 1);
        }
        return ret /= comb.fact[k];
    }


snippet extended_gcd

    template<typename T>
    T extended_gcd(T a, T b, T& x, T& y) {
        // solve ax + by = gcd(a, b)
        if (b == 0) { x = 1; y = 0; return a; }

        T X, Y;
        T g = extended_gcd(b, a % b, X, Y);
        x = Y; y = X - a/b * Y;
        return g;
    }


snippet partition

    // Partition function
    // Partition(k, n) := the number of cases
    //            to split n balls(not distinguished)
    //            into k boxes(not distinguished)
    template<typename Ring>
    Ring Partition(int k, int n) {
        vector<vector<Ring>> part(k+1, vector<Ring>(n+1));
        part[0][0] = 1;
        for (int i = 1; i <= k; ++i) {
            for (int j = 0; j <= n; ++j) {
                if (j-i >= 0) {
                    part[i][j] = part[i-1][j] + part[i][j-i];
                } else {
                    part[i][j] = part[i-1][j];
                }
            }
        }
        return part[k][n];
    }


snippet lowest_common_ancestor

    struct LCA {
        int n, log2_n;
        vector<int> depth;
        vector<vector<int>> par;

        void dfs(const vector<vector<int>>& G, int v, int p, int d) {
            depth[v] = d;
            par[0][v] = p;
            for (auto to : G[v]) {
                if (to != p) dfs(G, to, v, d+1);
            }
        }

        LCA(const vector<vector<int>>& G, int root=0) :
                n(G.size()), log2_n(log2(n)), depth(n),
                par(log2_n+1, vector<int>(n,-1)) {

            dfs(G, root, -1, 0);
            for (int k = 0; k < log2_n; ++k) {
                for (int v = 0; v < n; ++v) {
                    if (par[k][v] != -1) {
                        par[k+1][v] = par[k][par[k][v]];
                    }
                }
            }
        }

        int query(int u, int v) {
            if (depth[u] > depth[v]) swap(u, v);

            // align the depth of u and v
            for (int k = 0; k <= log2_n; ++k) {
                if ((depth[v] - depth[u]) >> k & 1) {
                    v = par[k][v];
                }
            }
            if (u == v) return u;

            // go back until u and v's parents do not match
            for (int k = log2_n; k >= 0; --k) {
                if (par[k][u] != par[k][v]) {
                    u = par[k][u];
                    v = par[k][v];
                }
            }
            return par[0][u];
        }
    };


snippet kruskal

    template<typename T>
    T kruskal(const vector<edge<T>> &es, int V) {

        UnionFind uf(V);
        T ret = 0;

        vector<int> ord(es.size());
        iota(ord.begin(), ord.end(), 0);
        sort(ord.begin(), ord.end(), [&](int i,int j){
                return es[i].cost < es[j].cost;
                });

        for (auto i : ord) {
            auto &e = es[i];
            if (!uf.issame(e.src, e.to)) {
                ret += e.cost;
                uf.merge(e.src, e.to);
            }
        }

        return ret;
    }


snippet dinic

    template<typename T>
    struct Dinic {
        const T INF;

        struct edge {
            int to;
            T cap;
            int rev;
            bool isrev;
        };

        vector<vector<edge>> g;
        vector<int> level, iter;

        Dinic(int V) : INF(numeric_limits<T>::max()), g(V) {}

        void add_edge(int src, int to, T cap) {
            g[src].push_back({to, cap, (int)g[to].size(), false});
            g[to].push_back({src, 0, (int)g[src].size()-1, true});
        }

        bool bfs(int s, int t) {
            level.assign(g.size(), -1);
            queue<int> que;
            level[s] = 0;
            que.push(s);
            while (!que.empty()) {
                int v = que.front();
                que.pop();
                for (auto &e : g[v]) {
                    if (e.cap > 0 && level[e.to] == -1) {
                        level[e.to] = level[v] + 1;
                        que.push(e.to);
                    }
                }
            }
            return level[t] != -1;
        }

        T dfs(int v, const int t, T flow) {
            if (v == t) return flow;
            for (int &i = iter[v]; i < g[v].size(); i++) {
                edge &e = g[v][i];
                if (e.cap > 0 && level[v] < level[e.to]) {
                    T d = dfs(e.to, t, min(flow, e.cap));
                    if (d > 0) {
                        e.cap -= d;
                        g[e.to][e.rev].cap += d;
                        return d;
                    }
                }
            }
            return 0;
        }

        T max_flow(int s, int t) {
            T flow = 0;
            while (bfs(s, t)) {
                iter.assign(g.size(), 0);
                T f = 0;
                while((f = dfs(s, t, INF)) > 0) flow += f;
            }
            return flow;
        }
    };


snippet dijkstra

    template<typename T>
    vector<T> dijkstra(const vector<vector<edge<T>>> &g, int s) {
        const T INF = numeric_limits<T>::max();
        vector<T> d(g.size(), INF);

        using Pi = pair<T, int>;
        priority_queue<Pi, vector<Pi>, greater<Pi>> que;
        d[s] = 0;
        que.emplace(d[s], s);
        while (!que.empty()) {
            T cost;
            int v;
            tie(cost, v) = que.top();
            que.pop();
            if (d[v] < cost) continue;
            for (auto &e : g[v]) {
                T nxt = cost + e.cost;
                if (d[e.to] > nxt) {
                    d[e.to] = nxt;
                    que.emplace(nxt, e.to);
                }
            }
        }
        return d;
    }


snippet warshall_floyd

    template<typename T>
    void warshall_floyd(vector<vector<T>> &g) {
        const auto INF = numeric_limits<T>::max();
        int n = g.size();
        for(int k = 0; k < n; k++) {
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    if(g[i][k] == INF || g[k][j] == INF) continue;
                    g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }
    }
