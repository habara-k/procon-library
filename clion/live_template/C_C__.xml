<templateSet group="C/C++">
  <template name="ford_fulkerson" value="&#10;template&lt;typename T&gt;&#10;struct FordFulkerson {&#10;    // O(FE)&#10;    struct edge {&#10;        int to, rev;&#10;        T cap;&#10;        edge(int to, T cap, int rev) :&#10;            to(to), cap(cap), rev(rev) {}&#10;    };&#10;&#10;    vector&lt;vector&lt;edge&gt;&gt; g;&#10;    vector&lt;int&gt; used;&#10;    const T INF;&#10;    int timestamp;&#10;&#10;    FordFulkerson(int n) :&#10;        INF(numeric_limits&lt;T&gt;::max()),&#10;        timestamp(0), g(n), used(n, -1) {}&#10;&#10;    void add_edge(int s, int t, T cap) {&#10;        g[s].emplace_back(t, cap, (int)g[t].size());&#10;        g[t].emplace_back(s,   0, (int)g[s].size() - 1);&#10;    }&#10;&#10;    T dfs(int v, const int t, T flow) {&#10;        if (v == t) return flow;&#10;        used[v] = timestamp;&#10;        for (edge &amp;e : g[v]) {&#10;            if (e.cap &gt; 0 and used[e.to] != timestamp) {&#10;                T d = dfs(e.to, t, min(flow, e.cap));&#10;                if (d &gt; 0) {&#10;                    e.cap -= d;&#10;                    g[e.to][e.rev].cap += d;&#10;                    return d;&#10;                }&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;&#10;    T max_flow(int s, int t) {&#10;        T flow = 0;&#10;        for (T f; (f = dfs(s, t, INF)) &gt; 0; timestamp++) {&#10;            flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;};&#10;" description="ford_fulkerson" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="euler_tour" value="&#10;struct EulerTour {&#10;    using G = vector&lt;vector&lt;int&gt;&gt;;&#10;    const G&amp; g;&#10;    vector&lt;int&gt; ds, us;&#10;&#10;    EulerTour(const G&amp; g) :&#10;        g(g), ds(g.size()), us(g.size()) {}&#10;&#10;    void dfs(int v, int p, int&amp; idx) {&#10;        for (int u : g[v]) {&#10;            if (u == p) continue;&#10;            ds[u] = idx++;&#10;            dfs(u, v, idx);&#10;            us[u] = idx++;&#10;        }&#10;    }&#10;&#10;    void build(int v) {&#10;        int idx = 1;&#10;        dfs(v, -1, idx);&#10;        us[v] = 2 * g.size() - 1;&#10;    }&#10;};&#10;" description="euler_tour" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="edge" value="&#10;template&lt;typename T&gt;&#10;struct edge {&#10;    int src, to;&#10;    T cost;&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const edge&amp; e) {&#10;        return os &lt;&lt; &quot;(&quot; &lt;&lt; e.src &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot;:&quot; &lt;&lt; e.cost &lt;&lt; &quot;)&quot;;&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;using Graph = vector&lt;vector&lt;edge&lt;T&gt;&gt;&gt;;&#10;&#10;" description="edge" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lowest_common_ancestor" value="&#10;struct LCA {&#10;    int n, log2_n;&#10;    vector&lt;int&gt; depth;&#10;    vector&lt;vector&lt;int&gt;&gt; par;&#10;&#10;    void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; G, int v, int p, int d) {&#10;        depth[v] = d;&#10;        par[0][v] = p;&#10;        for (auto to : G[v]) {&#10;            if (to != p) dfs(G, to, v, d+1);&#10;        }&#10;    }&#10;&#10;    LCA(const vector&lt;vector&lt;int&gt;&gt;&amp; G, int root=0) :&#10;            n(G.size()), log2_n(log2(n)), depth(n),&#10;            par(log2_n+1, vector&lt;int&gt;(n,-1)) {&#10;&#10;        dfs(G, root, -1, 0);&#10;        for (int k = 0; k &lt; log2_n; ++k) {&#10;            for (int v = 0; v &lt; n; ++v) {&#10;                if (par[k][v] != -1) {&#10;                    par[k+1][v] = par[k][par[k][v]];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    int query(int u, int v) const {&#10;        if (depth[u] &gt; depth[v]) swap(u, v);&#10;&#10;        // align the depth of u and v&#10;        for (int k = 0; k &lt;= log2_n; ++k) {&#10;            if ((depth[v] - depth[u]) &gt;&gt; k &amp; 1) {&#10;                v = par[k][v];&#10;            }&#10;        }&#10;        if (u == v) return u;&#10;&#10;        // go back until u and v's parents do not match&#10;        for (int k = log2_n; k &gt;= 0; --k) {&#10;            if (par[k][u] != par[k][v]) {&#10;                u = par[k][u];&#10;                v = par[k][v];&#10;            }&#10;        }&#10;        return par[0][u];&#10;    }&#10;};&#10;" description="lowest_common_ancestor" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="topological_sort" value="&#10;vector&lt;int&gt; topological_sort(const vector&lt;vector&lt;int&gt;&gt;&amp; G)&#10;{&#10;    int n = G.size();&#10;    vector&lt;int&gt; num(n), ord;&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        for (int u : G[i]) ++num[u];&#10;    }&#10;    stack&lt;int&gt; st;&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        if (num[i] == 0) st.push(i);&#10;    }&#10;    while (!st.empty()) {&#10;        int i = st.top(); st.pop();&#10;        ord.push_back(i);&#10;        for (int u : G[i]) {&#10;            --num[u];&#10;            if (num[u] == 0) st.push(u);&#10;        }&#10;    }&#10;    return ord;&#10;}&#10;" description="topological_sort" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="primal_dual" value="&#10;template&lt;typename flow_t, typename cost_t&gt;&#10;struct PrimalDual {&#10;    // O(FElogV)&#10;    struct edge {&#10;        int to, rev;&#10;        flow_t cap;&#10;        cost_t cost;&#10;        edge(int to, flow_t cap, cost_t cost, int rev) :&#10;                to(to), cap(cap), cost(cost), rev(rev) {}&#10;    };&#10;&#10;    vector&lt;vector&lt;edge&gt;&gt; g;&#10;    const int sz;&#10;    const cost_t INF;&#10;&#10;    PrimalDual(int V, cost_t INF) : g(V), sz(V), INF(INF) {}&#10;&#10;    void add_edge(int s, int t, flow_t cap, cost_t cost) {&#10;        g[s].emplace_back(t, cap,  cost, (int)g[t].size());&#10;        g[t].emplace_back(s,   0, -cost, (int)g[s].size() - 1);&#10;    }&#10;&#10;    void dijkstra(&#10;            vector&lt;cost_t&gt;&amp; dist,&#10;            vector&lt;int&gt;&amp; prevv,&#10;            vector&lt;int&gt;&amp; preve,&#10;            const vector&lt;cost_t&gt;&amp; potential, int s)&#10;    {&#10;        dist.assign(sz, INF);&#10;        prevv.assign(sz, -1);&#10;        preve.assign(sz, -1);&#10;        using Pi = pair&lt;cost_t, int&gt;;&#10;        priority_queue&lt;Pi, vector&lt;Pi&gt;, greater&lt;Pi&gt;&gt; que;&#10;        que.emplace(0, s);&#10;        dist[s] = 0;&#10;        while (!que.empty()) {&#10;            cost_t cost; int v;&#10;            std::tie(cost, v) = que.top();&#10;            que.pop();&#10;            if (dist[v] &lt; cost) continue;&#10;            for (int i = 0; i &lt; g[v].size(); ++i) {&#10;                edge &amp;e = g[v][i];&#10;&#10;                if (e.cost == INF or e.cost == -INF) continue;&#10;&#10;                cost_t nextCost =&#10;                        dist[v] + e.cost + potential[v] - potential[e.to];&#10;                if (e.cap &gt; 0 and dist[e.to] &gt; nextCost) {&#10;                    dist[e.to] = nextCost;&#10;                    prevv[e.to] = v, preve[e.to] = i;&#10;                    que.emplace(dist[e.to], e.to);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    cost_t min_cost_flow(int s, int t, flow_t f) {&#10;        cost_t ret = 0;&#10;        vector&lt;cost_t&gt; potential(sz, 0);&#10;&#10;        while (f &gt; 0)&#10;        {&#10;            vector&lt;cost_t&gt; dist;&#10;            vector&lt;int&gt; prevv, preve;&#10;            dijkstra(dist, prevv, preve, potential, s);&#10;&#10;            if (dist[t] == INF) return -1;&#10;&#10;            for (int v = 0; v &lt; sz; ++v) potential[v] += dist[v];&#10;&#10;            flow_t diff = f;&#10;            for (int v = t; v != s; v = prevv[v]) {&#10;                diff = min(diff, g[prevv[v]][preve[v]].cap);&#10;            }&#10;            f -= diff;&#10;            ret += diff * potential[t];&#10;&#10;            for (int v = t; v != s; v = prevv[v]) {&#10;                edge &amp;e = g[prevv[v]][preve[v]], &amp;re = g[v][e.rev];&#10;                e.cap -= diff;&#10;                re.cap += diff;&#10;            }&#10;        }&#10;&#10;        return ret;&#10;    }&#10;};&#10;" description="primal_dual" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="re_rooting" value="&#10;template&lt;typename Data, typename T&gt;&#10;struct ReRooting {&#10;&#10;    struct edge {&#10;        int to, rev;&#10;        Data data;&#10;    };&#10;&#10;    using F1 = function&lt;T(T, T)&gt;;&#10;    using F2 = function&lt;T(T, Data)&gt;;&#10;&#10;    vector&lt;vector&lt;edge&gt;&gt; g;&#10;    vector&lt;vector&lt;T&gt;&gt; ldp, rdp;&#10;    vector&lt;int&gt; lptr, rptr;&#10;    const F1 f1;&#10;    const F2 f2;&#10;    const T init;&#10;&#10;    ReRooting(int n, const F1 &amp;f1, const F2 &amp;f2, const T &amp;init) :&#10;        g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), init(init) {}&#10;&#10;    void add_edge(int u, int v, const Data &amp;d) {&#10;        g[u].emplace_back((edge){v, (int)g[v].size(), d});&#10;        g[v].emplace_back((edge){u, (int)g[u].size()-1, d});&#10;    }&#10;&#10;    T dfs(int idx, int par) {&#10;&#10;        while (lptr[idx] != par and lptr[idx] &lt; g[idx].size()) {&#10;            auto &amp;e = g[idx][lptr[idx]];&#10;            ldp[idx][lptr[idx]+1] = f1(&#10;                    ldp[idx][lptr[idx]],&#10;                    f2(dfs(e.to, e.rev), e.data));&#10;            ++lptr[idx];&#10;        }&#10;        while (rptr[idx] != par and rptr[idx] &gt;= 0) {&#10;            auto &amp;e = g[idx][rptr[idx]];&#10;            rdp[idx][rptr[idx]] = f1(&#10;                    rdp[idx][rptr[idx]+1],&#10;                    f2(dfs(e.to, e.rev), e.data));&#10;            --rptr[idx];&#10;        }&#10;        if (par &lt; 0) return rdp[idx][0];&#10;        return f1(ldp[idx][par], rdp[idx][par+1]);&#10;    }&#10;&#10;    vector&lt;T&gt; solve() {&#10;        for (int i = 0; i &lt; g.size(); ++i) {&#10;            ldp[i].assign(g[i].size()+1, init);&#10;            rdp[i].assign(g[i].size()+1, init);&#10;            lptr[i] = 0;&#10;            rptr[i] = (int)g[i].size()-1;&#10;        }&#10;        vector&lt;T&gt; ret(g.size());&#10;        for (int i = 0; i &lt; g.size(); ++i) {&#10;            ret[i] = dfs(i, -1);&#10;        }&#10;        return ret;&#10;    }&#10;};&#10;" description="re_rooting" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dijkstra" value="&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; dijkstra(const Graph&lt;T&gt;&amp; g, int s) {&#10;    const T infty = numeric_limits&lt;T&gt;::max();&#10;    vector&lt;T&gt; d(g.size(), infty);&#10;&#10;    using Pi = pair&lt;T, int&gt;;&#10;    priority_queue&lt;Pi, vector&lt;Pi&gt;, greater&lt;Pi&gt;&gt; que;&#10;    d[s] = 0;&#10;    que.emplace(d[s], s);&#10;    while (!que.empty()) {&#10;        auto [cost, v] = que.top();&#10;        que.pop();&#10;        if (d[v] &lt; cost) continue;&#10;        for (const auto &amp;e : g[v]) {&#10;            if (T alt = cost + e.cost; d[e.to] &gt; alt) {&#10;                d[e.to] = alt;&#10;                que.emplace(alt, e.to);&#10;            }&#10;        }&#10;    }&#10;    return d;&#10;}&#10;" description="dijkstra" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="strongly_connected_components" value="&#10;struct StronglyConnectedComponents {&#10;    int n;&#10;    vector&lt;vector&lt;int&gt;&gt; g, rg, graph;&#10;    vector&lt;int&gt; ord, used, comp;&#10;&#10;    StronglyConnectedComponents(const vector&lt;vector&lt;int&gt;&gt;&amp; g) :&#10;            n(g.size()), g(g), rg(n), used(n), comp(n, -1)&#10;    {&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            for (int to : g[i]) {&#10;                rg[to].push_back(i);&#10;            }&#10;        }&#10;    }&#10;&#10;    void build() {&#10;        for (int i = 0; i &lt; n; ++i) dfs(i);&#10;        reverse(ord.begin(), ord.end());&#10;        int ptr = 0;&#10;        for (int i : ord) if (comp[i] == -1) rdfs(i, ptr), ptr++;&#10;&#10;        graph.resize(ptr);&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            for (int to : g[i]) {&#10;                int x = comp[i], y = comp[to];&#10;                if (x == y) continue;&#10;                graph[x].push_back(y);&#10;            }&#10;        }&#10;        for (auto&amp; v : graph) {&#10;            sort(v.begin(), v.end());&#10;            v.erase(unique(v.begin(), v.end()), v.end());&#10;        }&#10;    }&#10;&#10;private:&#10;    void dfs(int idx) {&#10;        if (used[idx]) return;&#10;        used[idx] = true;&#10;        for (int to : g[idx]) dfs(to);&#10;        ord.push_back(idx);&#10;    }&#10;&#10;    void rdfs(int idx, int cnt) {&#10;        if (comp[idx] != -1) return;&#10;        comp[idx] = cnt;&#10;        for (int to : rg[idx]) rdfs(to, cnt);&#10;    }&#10;};&#10;&#10;" description="strongly_connected_components" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lowlink" value="&#10;struct LowLink {&#10;    // require: undirected simple graph&#10;    vector&lt;vector&lt;int&gt;&gt; g;&#10;    const int sz;&#10;    vector&lt;int&gt; ord, low, par;&#10;    vector&lt;int&gt; used, _is_articulation;&#10;    vector&lt;int&gt; articulations;&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridges;&#10;&#10;    LowLink(const vector&lt;vector&lt;int&gt;&gt;&amp; g) :&#10;        g(g), sz(g.size()), ord(sz), low(sz), used(sz),&#10;        par(sz), _is_articulation(sz) {}&#10;&#10;    void build() {&#10;        int k = 0;&#10;        for (int i = 0; i &lt; sz; ++i) {&#10;            if (!used[i]) dfs(i, -1, k);&#10;        }&#10;    }&#10;&#10;    void dfs(int v, int p, int&amp; k) {&#10;        used[v] = 1;&#10;        par[v] = p;&#10;        low[v] = ord[v] = k++;&#10;        int cnt = 0;&#10;        for (int to : g[v]) {&#10;            if (!used[to]) {&#10;                ++cnt;&#10;                dfs(to, v, k);&#10;                low[v] = min(low[v], low[to]);&#10;                _is_articulation[v] |= ord[v] &lt;= low[to];&#10;                if (ord[v] &lt; low[to]) {&#10;                    bridges.emplace_back(minmax(to, v));&#10;                }&#10;            } else if (to != p) {&#10;                low[v] = min(low[v], ord[to]);&#10;            }&#10;        }&#10;        if (p == -1) _is_articulation[v] = cnt &gt; 1;&#10;        if (_is_articulation[v]) articulations.push_back(v);&#10;    }&#10;&#10;    bool is_articulation(int v) const { return _is_articulation[v]; }&#10;    bool is_bridge(int u, int v) const {&#10;        if (u != par[v] and v != par[u]) return false;&#10;        if (u == par[v]) swap(u, v);&#10;        return ord[v] &lt; low[u];&#10;    }&#10;};&#10;" description="lowlink" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="kruskal" value="&#10;template&lt;typename T&gt;&#10;T kruskal(const vector&lt;edge&lt;T&gt;&gt; &amp;es, int V) {&#10;&#10;    UnionFind uf(V);&#10;    T ret = 0;&#10;&#10;    vector&lt;int&gt; ord(es.size());&#10;    iota(ord.begin(), ord.end(), 0);&#10;    sort(ord.begin(), ord.end(), [&amp;](int i,int j){&#10;            return es[i].cost &lt; es[j].cost;&#10;            });&#10;&#10;    for (auto i : ord) {&#10;        auto &amp;e = es[i];&#10;        if (!uf.issame(e.src, e.to)) {&#10;            ret += e.cost;&#10;            uf.merge(e.src, e.to);&#10;        }&#10;    }&#10;&#10;    return ret;&#10;}&#10;" description="kruskal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="warshall_floyd" value="&#10;template&lt;typename T&gt;&#10;void warshall_floyd(vector&lt;vector&lt;T&gt;&gt; &amp;g) {&#10;    const T INF = numeric_limits&lt;T&gt;::max();&#10;    int n = g.size();&#10;    for (int k = 0; k &lt; n; ++k) {&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            for (int j = 0; j &lt; n; ++j) {&#10;                if (g[i][k] == INF or g[k][j] == INF) continue;&#10;                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="warshall_floyd" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="maximum_clique" value="&#10;template&lt;typename T&gt;&#10;T maximum_clique(&#10;        vector&lt;vector&lt;bool&gt;&gt; G,&#10;        const function&lt;T(const vector&lt;int&gt;&amp;)&gt;&amp; f) {&#10;&#10;    // O(2^sqrt(2M) N) ?&#10;&#10;    // G: undirected graph (matrix)&#10;    // f: return max(f(clique set))&#10;&#10;    T ret = numeric_limits&lt;T&gt;::min();&#10;&#10;    int n = G.size();&#10;    vector&lt;int&gt; deg(n);&#10;    int M = 0;  // |edge|&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        for (int j = i+1; j &lt; n; ++j) {&#10;            if (G[i][j]) ++deg[i], ++deg[j], ++M;&#10;        }&#10;    }&#10;    vector&lt;bool&gt; used(n);&#10;&#10;    int lim = sqrt(2*M);&#10;&#10;    while (true) {&#10;        int u = -1;&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            if (!used[i] and deg[i] &lt; lim) {&#10;                u = i;&#10;                used[u] = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        vector&lt;int&gt; neighbor;&#10;        if (u != -1) neighbor.push_back(u);&#10;        for (int v = 0; v &lt; n; ++v) if (!used[v]) {&#10;            if (u == -1 or G[u][v]) {&#10;                neighbor.push_back(v);&#10;            }&#10;        }&#10;&#10;        int sz = neighbor.size();&#10;        vector&lt;int&gt; bit(sz);&#10;        for (int i = 0; i &lt; sz; ++i) {&#10;            for (int j = 0; j &lt; sz; ++j) {&#10;                if (G[neighbor[i]][neighbor[j]]) {&#10;                    bit[i] |= 1 &lt;&lt; j;&#10;                }&#10;            }&#10;        }&#10;&#10;        vector&lt;bool&gt; dp(1&lt;&lt;sz);&#10;        dp[0] = true;&#10;        for (int s = 1; s &lt; 1&lt;&lt;sz; ++s) {&#10;            int i = __builtin_ffs(s) - 1;&#10;            dp[s] = dp[s &amp; ~(1&lt;&lt;i)] and (~bit[i] &amp; s) == 0;&#10;            if (dp[s]) {&#10;                vector&lt;int&gt; vs;&#10;                for (int i = 0; i &lt; sz; ++i) if (s &gt;&gt; i &amp; 1) {&#10;                    vs.push_back(neighbor[i]);&#10;                }&#10;                ret = max(ret, f(vs));&#10;            }&#10;        }&#10;&#10;        if (u == -1) break;&#10;&#10;        for (int v : neighbor) {&#10;            --deg[v], --deg[u];&#10;            G[u][v] = G[v][u] = false;&#10;        }&#10;    }&#10;&#10;    return ret;&#10;}&#10;" description="maximum_clique" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dinic" value="&#10;template&lt;typename T&gt;&#10;struct Dinic {&#10;    // O(EV^2)&#10;    struct edge {&#10;        int to, rev;&#10;        T cap;&#10;        edge(int to, T cap, int rev) :&#10;            to(to), cap(cap), rev(rev) {}&#10;    };&#10;&#10;    vector&lt;vector&lt;edge&gt;&gt; g;&#10;    vector&lt;int&gt; level, iter;&#10;    const T INF;&#10;&#10;    Dinic(int V) : INF(numeric_limits&lt;T&gt;::max()), g(V) {}&#10;&#10;    void add_edge(int s, int t, T cap) {&#10;        g[s].emplace_back(t, cap, (int)g[t].size());&#10;        g[t].emplace_back(s,   0, (int)g[s].size() - 1);&#10;    }&#10;&#10;    bool bfs(int s, int t) {&#10;        level.assign(g.size(), -1);&#10;        queue&lt;int&gt; que;&#10;        level[s] = 0;&#10;        que.push(s);&#10;        while (!que.empty()) {&#10;            int v = que.front();&#10;            que.pop();&#10;            for (auto &amp;e : g[v]) {&#10;                if (e.cap &gt; 0 and level[e.to] == -1) {&#10;                    level[e.to] = level[v] + 1;&#10;                    que.push(e.to);&#10;                }&#10;            }&#10;        }&#10;        return level[t] != -1;&#10;    }&#10;&#10;    T dfs(int v, const int t, T flow) {&#10;        if (v == t) return flow;&#10;        for (int &amp;i = iter[v]; i &lt; g[v].size(); ++i) {&#10;            edge &amp;e = g[v][i];&#10;            if (e.cap &gt; 0 and level[v] &lt; level[e.to]) {&#10;                T d = dfs(e.to, t, min(flow, e.cap));&#10;                if (d &gt; 0) {&#10;                    e.cap -= d;&#10;                    g[e.to][e.rev].cap += d;&#10;                    return d;&#10;                }&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;&#10;    T max_flow(int s, int t) {&#10;        T flow = 0;&#10;        while (bfs(s, t)) {&#10;            iter.assign(g.size(), 0);&#10;            T f = 0;&#10;            while ((f = dfs(s, t, INF)) &gt; 0) flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;};&#10;" description="dinic" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="two_edge_connected_components" value="&#10;struct TwoEdgeConnectedComponents {&#10;    // require: undirected simple graph&#10;    vector&lt;vector&lt;int&gt;&gt; t;&#10;    vector&lt;int&gt; comp;&#10;    LowLink lowlink;&#10;&#10;    TwoEdgeConnectedComponents(const vector&lt;vector&lt;int&gt;&gt;&amp; g) :&#10;        lowlink(g), comp(g.size(), -1) {}&#10;&#10;    void dfs(int v, int p, int&amp; k) {&#10;        if (p == -1 or lowlink.is_bridge(v, p)) comp[v] = k++;&#10;        else comp[v] = comp[p];&#10;        for (int to : lowlink.g[v]) {&#10;            if (comp[to] == -1) dfs(to, v, k);&#10;        }&#10;    }&#10;&#10;    void build() {&#10;        lowlink.build();&#10;        int k = 0;&#10;        for (int i = 0; i &lt; comp.size(); ++i) {&#10;            if (comp[i] == -1) dfs(i, -1, k);&#10;        }&#10;        t.resize(k);&#10;        for (const auto&amp; tp : lowlink.bridges) {&#10;            int u = comp[tp.first], v = comp[tp.second];&#10;            t[u].push_back(v);&#10;            t[v].push_back(u);&#10;        }&#10;    }&#10;};&#10;" description="two_edge_connected_components" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="heavy_light_decomposition" value="&#10;struct HLDecomposition {&#10;    const vector&lt;vector&lt;int&gt;&gt;&amp; G;&#10;    vector&lt;int&gt; par, size, depth, head, vid;&#10;    // par[v]: parent of v&#10;    // size[v]: size of subtree[v]&#10;    // depth[v]: depth of v. depth[root] = 0&#10;    // head[v]: head of row containing v&#10;    // vid[v]: index of v when all the rows are aligned.&#10;&#10;    void dfs(int v, int p, int d) {&#10;        par[v] = p; depth[v] = d; size[v] = 1;&#10;        for (int u : G[v]) {&#10;            if (u == p) continue;&#10;            dfs(u, v, d+1);&#10;            size[v] += size[u];&#10;        }&#10;    }&#10;    void hld(int v, int h, int&amp; k) {&#10;        head[v] = h; vid[v] = k++;&#10;        int ma = 0, id = -1;&#10;        for (int u : G[v]) {&#10;            if (u == par[v]) continue;&#10;            if (chmax(ma, size[u])) id = u;&#10;        }&#10;        if (id == -1) return;&#10;        hld(id, h, k);&#10;        for (int u : G[v]) {&#10;            if (u == id or u == par[v]) continue;&#10;            hld(u, u, k);&#10;        }&#10;    }&#10;&#10;    HLDecomposition(const vector&lt;vector&lt;int&gt;&gt;&amp; g) :&#10;        G(g), par(g.size()), size(g.size()), depth(g.size()),&#10;        head(g.size()), vid(g.size()) {}&#10;&#10;    void build(int root = 0) {&#10;        dfs(root, -1, 0);&#10;        int k = 0;&#10;        hld(root, root, k);&#10;    }&#10;&#10;    int lca(int u, int v) const {&#10;        for (;; v = par[head[v]]) {&#10;            if (depth[head[u]] &gt; depth[head[v]]) swap(u, v);&#10;            if (head[u] == head[v]) {&#10;                if (depth[u] &gt; depth[v]) swap(u, v);&#10;                return u;&#10;            }&#10;        }&#10;    }&#10;&#10;    template&lt;typename UpdateQuery&gt;&#10;    void update(int u, int v, const UpdateQuery&amp; q, bool edge = false) const {&#10;        // q(a, b): update [a, b).&#10;        for (;; v = par[head[v]]) {&#10;            if (depth[head[u]] &gt; depth[head[v]]) swap(u, v);&#10;            if (head[u] == head[v]) {&#10;                if (vid[u] &gt; vid[v]) swap(u, v);&#10;                q(vid[u] + edge, vid[v] + 1);&#10;                break;&#10;            } else {&#10;                q(vid[head[v]], vid[v] + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    template&lt;typename Query, typename MergeFunc, typename T&gt;&#10;    T query(int u, int v,&#10;            const Query&amp; q, const MergeFunc&amp; f,&#10;            const T&amp; ident, bool edge = false) const {&#10;        // q(a, b): return f[a, b).&#10;        // f: 二つの区間の要素をマージする関数&#10;        // ident: モノイドの単位元&#10;        T ret = ident;&#10;        for (;; v = par[head[v]]) {&#10;            if (depth[head[u]] &gt; depth[head[v]]) swap(u, v);&#10;            if (head[u] == head[v]) {&#10;                if (vid[u] &gt; vid[v]) swap(u, v);&#10;                return f(ret, q(vid[u] + edge, vid[v] + 1));&#10;            } else {&#10;                ret = f(ret, q(vid[head[v]], vid[v] + 1));&#10;            }&#10;        }&#10;    }&#10;};&#10;" description="heavy_light_decomposition" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="2D_template" value="&#10;using Real = double;&#10;const Real PI = acos(-1);&#10;&#10;using Point = complex&lt;Real&gt;;&#10;namespace std {&#10;    bool operator&lt;(const Point&amp; a, const Point&amp; b) {&#10;        if (a.real() == b.real()) return a.imag() &lt; b.imag();&#10;        return a.real() &lt; b.real();&#10;    }&#10;}&#10;struct Line {&#10;    Point a, b;&#10;    Line() {}&#10;    Line(const Point&amp; a, const Point&amp; b) : a(a), b(b) {}&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Line&amp; l) {&#10;        return os &lt;&lt; &quot;[&quot; &lt;&lt; l.a &lt;&lt; &quot;,&quot; &lt;&lt; l.b &lt;&lt; &quot;]&quot;;&#10;    }&#10;};&#10;struct Segment : Line {&#10;    Segment() = default;&#10;&#10;    Segment(const Point&amp; a, const Point&amp; b) : Line(a, b) {}&#10;};&#10;&#10;inline bool eq(Real a, Real b) { return abs(b - a) &lt; EPS; }&#10;&#10;Real radian_to_degree(Real r) {&#10;    return r * 180.0 / PI;&#10;}&#10;&#10;Real degree_to_radian(Real d) {&#10;    return d * PI / 180.0;&#10;}&#10;&#10;Point rotate(const Point &amp;p, Real theta) {&#10;    return p * polar((Real)1.0, theta);&#10;}&#10;&#10;Real cross(const Point&amp; a, const Point&amp; b) {&#10;    return a.real() * b.imag() - a.imag() * b.real();&#10;}&#10;&#10;Real dot(const Point&amp; a, const Point&amp; b) {&#10;    return a.real() * b.real() + a.imag() * b.imag();&#10;}&#10;&#10;Point projection(const Line&amp; l, const Point&amp; p) {&#10;    Real A = dot(l.b - l.a, p - l.a),&#10;         B = dot(l.a - l.b, p - l.b);&#10;    return (A * l.b + B * l.a) / (A + B);&#10;}&#10;&#10;bool parallel(const Line&amp; l1, const Line&amp; l2) {&#10;    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);&#10;}&#10;&#10;bool orthogonal(const Line&amp; l1, const Line&amp; l2) {&#10;    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);&#10;}&#10;&#10;const int COUNTER_CLOCKWISE = 1,&#10;          CLOCKWISE = -1,&#10;          ONLINE_BACK = 2,&#10;          ONLINE_FRONT = -2,&#10;          ON_SEGMENT = 0;&#10;int ccw(const Point&amp; a, Point b, Point c) {&#10;    b = b - a, c = c - a;&#10;    if (cross(b, c) &gt; EPS) return COUNTER_CLOCKWISE;&#10;    if (cross(b, c) &lt; -EPS) return CLOCKWISE;&#10;    if (dot(b, c) &lt; 0) return ONLINE_BACK;&#10;    if (norm(b) &lt; norm(c)) return ONLINE_FRONT;&#10;    return ON_SEGMENT;&#10;}&#10;&#10;bool intersected(const Line&amp; l, const Point&amp; p) {&#10;    return abs(ccw(l.a, l.b, p)) != 1;&#10;}&#10;&#10;bool intersected(const Segment&amp; s, const Point&amp; p) {&#10;    return ccw(s.a, s.b, p) == 0;&#10;}&#10;&#10;bool intersected(const Line&amp; l, const Segment&amp; s) {&#10;    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) &lt; EPS;&#10;}&#10;&#10;bool intersected(const Segment&amp; s1, const Segment&amp; s2) {&#10;    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) &lt;= 0 and&#10;           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) &lt;= 0;&#10;}&#10;&#10;Real distance(const Line&amp; l, const Point&amp; p) {&#10;    return abs(p - projection(l, p));&#10;}&#10;&#10;Real distance(const Segment&amp; s, const Point&amp; p) {&#10;    Point r = projection(s, p);&#10;    if (intersected(s, r)) return abs(r - p);&#10;    return min(abs(s.a - p), abs(s.b - p));&#10;}&#10;&#10;Real distance(const Line &amp;l, const Segment &amp;s) {&#10;    if (intersected(l, s)) return 0;&#10;    return min(distance(l, s.a), distance(l, s.b));&#10;}&#10;&#10;Real distance(const Segment&amp; s1, const Segment&amp; s2) {&#10;    if (intersected(s1, s2)) return 0.0;&#10;    return min({ distance(s1, s2.a), distance(s1, s2.b),&#10;                 distance(s2, s1.a), distance(s2, s1.b) });&#10;}&#10;&#10;Point crosspoint(const Line&amp; l1, const Line&amp; l2) {&#10;    Real A = cross(l2.a - l1.a, l2.b - l1.a),&#10;         B = cross(l2.b - l1.b, l2.a - l1.b);&#10;    return (A * l1.b + B * l1.a) / (A + B);&#10;}&#10;&#10;struct Circle {&#10;    Point p;&#10;    Real r;&#10;    Circle() {}&#10;    Circle(const Point&amp; p, Real r) : p(p), r(r) {}&#10;};&#10;&#10;&#10;int intersected(Circle c1, Circle c2) {&#10;    if (c1.r &lt; c2.r) swap(c1, c2);&#10;    Real d = abs(c1.p - c2.p);&#10;    if (c1.r + c2.r &lt; d) return 4;&#10;    if (eq(c1.r + c2.r, d)) return 3;&#10;    if (c1.r - c2.r &lt; d) return 2;&#10;    if (eq(c1.r - c2.r, d)) return 1;&#10;    return 0;&#10;}&#10;&#10;pair&lt;Point,Point&gt; crosspoint(const Circle&amp; c, const Line&amp; l) {&#10;    Real h = distance(l, c.p);&#10;    Point p = projection(l, c.p);&#10;    if (eq(h, c.r)) return { p, p };&#10;    Point u = l.a - l.b; u /= abs(u);&#10;    Real d = sqrt(c.r * c.r - h * h);&#10;    return { p + u * d, p - u * d };&#10;}&#10;&#10;pair&lt;Point,Point&gt; crosspoint(const Circle&amp; c1, const Circle&amp; c2) {&#10;    Real d = abs(c2.p - c1.p), t = arg(c2.p - c1.p);&#10;    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));&#10;    return { c1.p + polar(c1.r, t + a),&#10;             c1.p + polar(c1.r, t - a) };&#10;}&#10;&#10;pair&lt;Point,Point&gt; tangent(const Point&amp; p, const Circle&amp; c) {&#10;    return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));&#10;};&#10;&#10;vector&lt;Line&gt; common_tangent(const Circle&amp; c1, const Circle&amp; c2) {&#10;    vector&lt;Line&gt; lines;&#10;    Point u = c2.p - c1.p;&#10;    Real d = abs(u);&#10;    if (eq(d, 0.0)) return lines;&#10;    u /= d;&#10;    for (Real s : { -1, 1 }) {&#10;        Real h = (c1.r + s * c2.r) / d;&#10;        if (eq(abs(h), 1.0)) {&#10;            lines.emplace_back(&#10;                    c1.p + u * h * c1.r,&#10;                    c1.p + u * h * c1.r + rotate(u, PI / 2.0));&#10;        } else if (abs(h) &lt; 1) {&#10;            Real a = acos(h);&#10;            lines.emplace_back(&#10;                    c1.p + u * polar(c1.r, a),&#10;                    c2.p - s * u * polar(c2.r, a));&#10;            lines.emplace_back(&#10;                    c1.p + u * polar(c1.r, -a),&#10;                    c2.p - s * u * polar(c2.r, -a));&#10;        }&#10;    }&#10;    return lines;&#10;}&#10;" description="2D_template" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="polygon" value="&#10;using Polygon = vector&lt;Point&gt;;&#10;&#10;Real area(const Polygon&amp; U) {&#10;    Real area = 0;&#10;    for (int i = 0; i &lt; U.size(); ++i) {&#10;        area += cross(U[i], U[(i + 1) % U.size()]);&#10;    }&#10;    return area / 2.0;&#10;}&#10;&#10;bool is_convex(const Polygon &amp;U) {&#10;    int n = U.size();&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;const int OUT = 0,&#10;          ON = 1,&#10;          IN = 2;&#10;int contains(const Polygon &amp;U, const Point &amp;p) {&#10;    int in = 0;&#10;    for (int i = 0; i &lt; U.size(); ++i) {&#10;        Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;&#10;        if (cross(a, b) == 0 and dot(a, b) &lt;= 0) return ON;&#10;        if (a.imag() &gt; b.imag()) swap(a, b);&#10;        if (a.imag() &lt;= 0 and 0 &lt; b.imag() and cross(a, b) &lt; 0) in ^= 1;&#10;    }&#10;    return in ? IN : OUT;&#10;}&#10;&#10;vector&lt;Point&gt; convex_hull(vector&lt;Point&gt;&amp; p, bool includeOnLine = false) {&#10;    int n = p.size(), k = 0;&#10;    if (n &lt;= 2) return p;&#10;    sort(p.begin(), p.end());&#10;    vector&lt;Point&gt; ch(n * 2);&#10;    const Real BOUND = includeOnLine ? -EPS : EPS;&#10;    for (int i = 0; i &lt; n; ch[k++] = p[i++]) {&#10;        while (k &gt;= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) &lt; BOUND) --k;&#10;    }&#10;    for (int i = n-2, t = k+1; i &gt;= 0; ch[k++] = p[i--]) {&#10;        while (k &gt;= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) &lt; BOUND) --k;&#10;    }&#10;    ch.resize(k-1);&#10;    return ch;&#10;}&#10;&#10;Real convex_diameter(const Polygon &amp;U) {&#10;    int n = U.size();&#10;    int is = 0, js = 0;&#10;    for (int i = 1; i &lt; n; ++i) {&#10;        if (U[i].imag() &gt; U[is].imag()) is = i;&#10;        if (U[i].imag() &lt; U[js].imag()) js = i;&#10;    }&#10;    Real maxnorm = norm(U[is] - U[js]);&#10;&#10;    int i = is, j = js;&#10;    do {&#10;        if (cross(U[(i+1) % n] - U[i], U[(j+1) % n] - U[j]) &gt;= 0) {&#10;            j = (j+1) % n;&#10;        } else {&#10;            i = (i+1) % n;&#10;        }&#10;        if (norm(U[i] - U[j]) &gt; maxnorm) {&#10;            maxnorm = norm(U[i] - U[j]);&#10;        }&#10;    } while (i != is or j != js);&#10;    return sqrt(maxnorm);&#10;}&#10;&#10;Polygon convex_cut(const Polygon&amp; U, const Line&amp; l) {&#10;    Polygon ret;&#10;    for (int i = 0; i &lt; U.size(); ++i) {&#10;        Point now = U[i], nxt = U[(i + 1) % U.size()];&#10;        if (ccw(l.a, l.b, now) != -1) ret.push_back(now);&#10;        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) == -1) {&#10;            ret.push_back(crosspoint(Line{ now, nxt }, l));&#10;        }&#10;    }&#10;    return ret;&#10;}&#10;&#10;Polygon voronoi_cell(const Point&amp; c, const vector&lt;Point&gt;&amp; ps, Polygon outer) {&#10;    for (const Point&amp; p : ps) {&#10;        Point m = (p + c) / 2.0;&#10;        outer = convex_cut(outer,&#10;                    Line{ m, m + rotate(p - c, M_PI / 2) });&#10;    }&#10;    return outer;&#10;}&#10;" description="polygon" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="3D_template" value="&#10;using Real = double;&#10;const Real PI = acos(-1);&#10;&#10;struct Point3D {&#10;    double x, y, z;&#10;    Point3D() {}&#10;    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}&#10;    Point3D operator+(const Point3D&amp; b) const {&#10;        return Point3D(x + b.x, y + b.y, z + b.z);&#10;    }&#10;    Point3D operator-(const Point3D&amp; b) const {&#10;        return Point3D(x - b.x, y - b.y, z - b.z);&#10;    }&#10;    friend double norm(const Point3D&amp; p) {&#10;        return p.x * p.x + p.y * p.y + p.z * p.z;&#10;    };&#10;    friend double abs(const Point3D&amp; p) { return sqrt(norm(p)); }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Point3D &amp;p) {&#10;        return os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;,&quot; &lt;&lt; p.z &lt;&lt; &quot;)&quot;;&#10;    }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Point3D &amp;p) {&#10;        return is &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.z;&#10;    }&#10;};&#10;struct Segment3D {&#10;    Point3D a, b;&#10;    Segment3D() {}&#10;    Segment3D(const Point3D&amp; a, const Point3D&amp; b) : a(a), b(b) {}&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Segment3D &amp;l) {&#10;        return os &lt;&lt; &quot;[&quot; &lt;&lt; l.a &lt;&lt; &quot;,&quot; &lt;&lt; l.b &lt;&lt; &quot;]&quot;;&#10;    }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Segment3D &amp;l) {&#10;        return is &gt;&gt; l.a &gt;&gt; l.b;&#10;    }&#10;};&#10;&#10;inline bool eq(Real a, Real b) { return abs(b - a) &lt; EPS; }&#10;&#10;double dot(const Point3D &amp;a, const Point3D &amp;b) {&#10;    return a.x * b.x + a.y * b.y + a.z * b.z;&#10;}&#10;&#10;Point3D cross(const Point3D &amp;a, const Point3D &amp;b) {&#10;    double x = a.y * b.z - a.z * b.y,&#10;           y = a.z * b.x - a.x * b.z,&#10;           z = a.x * b.y - a.y * b.x;&#10;    return Point3D(x, y, z);&#10;}&#10;&#10;bool parallel(&#10;        const Point3D &amp;a1, const Point3D &amp;a2,&#10;        const Point3D &amp;b1, const Point3D &amp;b2) {&#10;    return eq(abs(cross(a1-b1, a2-b2)), 0.);&#10;}&#10;&#10;bool parallel(const Segment3D&amp; l1, const Segment3D&amp; l2) {&#10;    return parallel(l1.a, l1.b, l2.a, l2.b);&#10;}&#10;&#10;double distance(const Segment3D &amp;l, const Point3D &amp;p) {&#10;    if (dot(l.b - l.a, p - l.a) &lt; EPS) return abs(p - l.a);&#10;    if (dot(l.a - l.b, p - l.b) &lt; EPS) return abs(p - l.b);&#10;    return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);&#10;}&#10;" description="3D_template" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="parser" value="&#10;using State = string::const_iterator;&#10;class ParseError {};&#10;" description="parser" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="expression" value="&#10;int number(State&amp; begin) {&#10;    int ret = 0;&#10;    while ('0' &lt;= *begin and *begin &lt;= '9') {&#10;        ret *= 10;&#10;        ret += *begin - '0';&#10;        ++begin;&#10;    }&#10;    return ret;&#10;}&#10;&#10;int expression(State&amp; begin);&#10;&#10;int factor(State&amp; begin) {&#10;    if (*begin == '(') {&#10;        ++begin;&#10;        int ret = expression(begin);&#10;        if (*begin != ')') {&#10;            throw ParseError();&#10;        }&#10;        ++begin;&#10;        return ret;&#10;    } else {&#10;        return number(begin);&#10;    }&#10;}&#10;&#10;int term(State&amp; begin) {&#10;    int prod = factor(begin);&#10;    while (true) {&#10;        if (*begin == '*') {&#10;            ++begin;&#10;            prod *= factor(begin);&#10;        }&#10;        else if (*begin == '/') {&#10;            ++begin;&#10;            prod /= factor(begin);&#10;        }&#10;        else {&#10;            return prod;&#10;        }&#10;    }&#10;}&#10;&#10;int expression(State&amp; begin) {&#10;    int sum = term(begin);&#10;    while (true) {&#10;        if (*begin == '+') {&#10;            ++begin;&#10;            sum += term(begin);&#10;        } else if (*begin == '-') {&#10;            ++begin;&#10;            sum -= term(begin);&#10;        } else {&#10;            return sum;&#10;        }&#10;    }&#10;}&#10;" description="expression" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dice" value="&#10;struct Dice {&#10;    int U, D, L, R, F, B;&#10;    Dice(int U, int D, int L, int R, int F, int B) :&#10;        U(U), D(D), L(L), R(R), F(F), B(B) {}&#10;&#10;    void rollU() {&#10;        int buff = F;&#10;        F = R; R = B; B = L; L = buff;&#10;    }&#10;    void rollD() {&#10;        int buff = F;&#10;        F = L; L = B; B = R; R = buff;&#10;    }&#10;    void rollF() {&#10;        int buff = U;&#10;        U = L; L = D; D = R; R = buff;&#10;    }&#10;    void rollB() {&#10;        int buff = U;&#10;        U = R; R = D; D = L; L = buff;&#10;    }&#10;    void rollR() {&#10;        int buff = U;&#10;        U = F; F = D; D = B; B = buff;&#10;    }&#10;    void rollL() {&#10;        int buff = U;&#10;        U = B; B = D; D = F; F = buff;&#10;    }&#10;};&#10;" description="dice" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="inversion" value="&#10;template&lt;typename T&gt;&#10;int64_t inversion(const vector&lt;T&gt;&amp; A)&#10;{&#10;    map&lt;T, int&gt; idx;&#10;    for (const T&amp; a : A) idx[a] = -1;&#10;&#10;    int cnt = 0;&#10;    for (auto&amp; p : idx) p.second = cnt++;&#10;&#10;    assert(cnt == A.size());&#10;&#10;    BIT&lt;int&gt; bit(cnt+1);&#10;    int64_t res = 0;&#10;    for (int i = 0; i &lt; A.size(); ++i) {&#10;        res += i - bit.sum(idx[A[i]]);&#10;        bit.add(idx[A[i]], 1);&#10;    }&#10;&#10;    return res;&#10;}&#10;" description="inversion" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="longest_increasing_subsequence" value="&#10;template&lt;typename T&gt;&#10;int LIS(const vector&lt;T&gt;&amp; a) {&#10;    int n = a.size();&#10;    T INF = numeric_limits&lt;T&gt;::max();&#10;    vector&lt;T&gt; dp(n, INF);&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        *lower_bound(dp.begin(), dp.end(), a[i]) = a[i];&#10;    }&#10;    return distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));&#10;}&#10;" description="longest_increasing_subsequence" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="combination" value="&#10;template&lt;typename Field&gt;&#10;struct Combination {&#10;    vector&lt;Field&gt; _fact, _rfact, _inv;&#10;&#10;    Combination(int n) : _fact(n), _rfact(n), _inv(n) {&#10;        _fact[0] = _rfact[n-1] = 1;&#10;        for (int i = 1; i &lt; n; ++i) _fact[i] = _fact[i-1] * i;&#10;        _rfact[n-1] /= _fact[n-1];&#10;        for (int i = n-1; i &gt; 0; --i) _rfact[i-1] = _rfact[i] * i;&#10;        for (int i = 1; i &lt; n; ++i) _inv[i] = _rfact[i] * _fact[i-1];&#10;    }&#10;&#10;    inline Field fact(int k) const { return _fact.at(k); }&#10;&#10;    inline Field rfact(int k) const { return _rfact.at(k); }&#10;&#10;    inline Field inv(int k) const { assert(k != 0); return _inv.at(k); }&#10;&#10;    Field P(int n, int r) const {&#10;        if (r &lt; 0 or n &lt; r) return 0;&#10;        return fact(n) * rfact(n-r);&#10;    }&#10;&#10;    Field C(int n, int r) const {&#10;        if (r &lt; 0 or n &lt; r) return 0;&#10;        return fact(n) * rfact(r) * rfact(n-r);&#10;    }&#10;&#10;    Field H (int n, int r) const {&#10;        return (n == 0 and r == 0) ? 1 : C(n+r-1, r);&#10;    }&#10;};&#10;" description="combination" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="bell" value="&#10;// Bell 数&#10;// Bell(n, k) := 区別できるn 個のボールを,&#10;//               区別できないk 個の箱に入れる場合の数&#10;template&lt;typename Field&gt;&#10;Field Bell(int64_t n, int k) {&#10;    Field ret = 0;&#10;    for (int i = 0; i &lt;= k; ++i) {&#10;        ret += Stirling&lt;Field&gt;(n, i);&#10;    }&#10;    return ret;&#10;}&#10;" description="bell" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="extended_gcd" value="&#10;template&lt;typename T&gt;&#10;T extended_gcd(T a, T b, T&amp; x, T&amp; y) {&#10;    // solve ax + by = gcd(a, b)&#10;    if (b == 0) { x = 1; y = 0; return a; }&#10;&#10;    T X, Y;&#10;    T g = extended_gcd(b, a % b, X, Y);&#10;    x = Y; y = X - a/b * Y;&#10;    return g;&#10;}&#10;" description="extended_gcd" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="euler_phi" value="&#10;// O(sqrt(n))&#10;int64_t euler_phi(int64_t n) {&#10;    int64_t ret = n;&#10;    for (int64_t i = 2; i * i &lt;= n; ++i) {&#10;        if (n % i != 0) continue;&#10;        ret -= ret / i;&#10;        while (n % i == 0) n /= i;&#10;    }&#10;    if (n &gt; 1) ret -= ret / n;&#10;    return ret;&#10;}&#10;" description="euler_phi" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="fast_zeta_transform" value="&#10;// O(NlogN)&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; fast_zeta_transform(const vector&lt;T&gt;&amp; f) {&#10;    // Return g(s):&#10;    // s.t. g(s) = \sum_{s \subset t} f(t)&#10;    int n = f.size();&#10;    vector&lt;T&gt; g = f;&#10;    for (int i = 0; (1 &lt;&lt; i) &lt; n; ++i) {&#10;        for (int j = 0; j &lt; n; ++j) {&#10;            if (!(j &gt;&gt; i &amp; 1)) {&#10;                g[j] += g[j | (1&lt;&lt;i)];&#10;            }&#10;        }&#10;    }&#10;    return g;&#10;}&#10;&#10;// O(NloglogN)&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; fast_zeta_transform_prime(const vector&lt;T&gt;&amp; f) {&#10;    // Return g(d):&#10;    // s.t. g(d) = \sum_{d | n} f(n)&#10;    int n = f.size();&#10;    vector&lt;T&gt; g = f;&#10;    vector&lt;bool&gt; sieve(n, true);&#10;    for (int p = 2; p &lt; n; ++p) {&#10;        if (!sieve[p]) continue;&#10;        for (int i = (n - 1) / p; i &gt; 0; --i) {&#10;            sieve[i * p] = false;&#10;            g[i] += g[i * p];&#10;        }&#10;    }&#10;    return g;&#10;}&#10;" description="fast_zeta_transform" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="prime_table" value="&#10;// O(nloglogn)&#10;vector&lt;bool&gt; prime_table(int n) {&#10;    n = max(n, 1);&#10;    vector&lt;bool&gt; prime(n+1, true);&#10;    prime[0] = prime[1] = false;&#10;    for (int i = 2; i * i &lt;= n; ++i) {&#10;        if (!prime[i]) continue;&#10;        for (int j = 2 * i; j &lt;= n; j += i) {&#10;            prime[j] = false;&#10;        }&#10;    }&#10;    return prime;&#10;}&#10;" description="prime_table" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="prime_factorize" value="&#10;// O(sqrt(n))&#10;map&lt;int64_t, int&gt; prime_factorize(int64_t n) {&#10;    map&lt;int64_t, int&gt; ret;&#10;    for (int64_t i = 2; i * i &lt;= n; ++i) {&#10;        while (n % i == 0) {&#10;            ret[i]++;&#10;            n /= i;&#10;        }&#10;    }&#10;    if (n != 1) ret[n] = 1;&#10;    return ret;&#10;}&#10;" description="prime_factorize" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modint" value="&#10;template&lt;int64_t mod&gt;&#10;class modint {&#10;    int64_t x;&#10;&#10;public:&#10;    modint(int64_t x = 0) : x(x &lt; 0 ? ((x % mod) + mod) % mod : x % mod) {}&#10;&#10;    const modint operator-() const { return x ? mod - x : 0; }&#10;&#10;    modint&amp; operator+=(const modint&amp; rhs) {&#10;        if ((x += rhs.x) &gt;= mod) x -= mod;&#10;        return *this;&#10;    }&#10;    modint&amp; operator-=(const modint&amp; rhs) {&#10;        return *this += -rhs;&#10;    }&#10;    modint&amp; operator*=(const modint&amp; rhs) {&#10;        (x *= rhs.x) %= mod;&#10;        return *this;&#10;    }&#10;    modint&amp; operator/=(const modint&amp; rhs) {&#10;        return *this *= rhs.pow(mod - 2);&#10;    }&#10;&#10;    friend const modint operator+(modint lhs, const modint&amp; rhs) {&#10;        return lhs += rhs;&#10;    }&#10;    friend const modint operator-(modint lhs, const modint&amp; rhs) {&#10;        return lhs -= rhs;&#10;    }&#10;    friend const modint operator*(modint lhs, const modint&amp; rhs) {&#10;        return lhs *= rhs;&#10;    }&#10;    friend const modint operator/(modint lhs, const modint&amp; rhs) {&#10;        return lhs /= rhs;&#10;    }&#10;&#10;    const modint pow(int64_t n) const {&#10;        modint ret = 1, tmp = *this;&#10;        while (n) {&#10;            if (n &amp; 1) ret *= tmp;&#10;            tmp *= tmp; n &gt;&gt;= 1;&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    friend bool operator==(const modint&amp; lhs, const modint&amp; rhs) {&#10;        return lhs.x == rhs.x;&#10;    }&#10;    friend bool operator!=(const modint&amp; lhs, const modint&amp; rhs) {&#10;        return !(lhs == rhs);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const modint&amp; a) {&#10;        return os &lt;&lt; a.x;&#10;    }&#10;    friend istream&amp; operator&gt;&gt;(istream&amp; is, modint&amp; a) {&#10;        int64_t tmp; is &gt;&gt; tmp; a = tmp;&#10;        return is;&#10;    }&#10;};&#10;" description="modint" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="fast_mobius_transform" value="&#10;// O(NlogN)&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; fast_mobius_transform(const vector&lt;T&gt;&amp; g) {&#10;    // Return f(s):&#10;    // s.t. g(s) = \sum_{s \subset t} f(t)&#10;    // ( e.g. f(s) = \sum_{s \subset t} (-1)^|t-s| * g(t) )&#10;    int n = g.size();&#10;    vector&lt;T&gt; f = g;&#10;    for (int i = 0; (1 &lt;&lt; i) &lt; n; ++i) {&#10;        for (int j = 0; j &lt; n; ++j) {&#10;            if (!(j &gt;&gt; i &amp; 1)) {&#10;                f[j] -= f[j | (1&lt;&lt;i)];&#10;            }&#10;        }&#10;    }&#10;    return f;&#10;}&#10;&#10;// O(NloglogN)&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; fast_mobius_transform_prime(const vector&lt;T&gt;&amp; g) {&#10;    // Return f(d):&#10;    // s.t. g(d) = \sum_{d | n} f(n)&#10;    // ( e.g. f(d) = \sum_{d | n} mu(n / d) * g(n) )&#10;    int n = g.size();&#10;    vector&lt;T&gt; f = g;&#10;    vector&lt;bool&gt; sieve(n, true);&#10;    for (int p = 2; p &lt; n; ++p) {&#10;        if (!sieve[p]) continue;&#10;        for (int i = 1; i * p &lt; n; ++i) {&#10;            sieve[i * p] = false;&#10;            f[i] -= f[i * p];&#10;        }&#10;    }&#10;    return f;&#10;}&#10;" description="fast_mobius_transform" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="stirling" value="&#10;// スターリング数&#10;// Stirling(n, k) := 区別できるn 個のボールを&#10;//                   区別できないk 個の箱に入れる場合の数&#10;//                   (ただし空箱はNG)&#10;template&lt;typename Field&gt;&#10;Field Stirling(int64_t n, int k) {&#10;    Combination&lt;Field&gt; comb(k+1);&#10;&#10;    Field ret = 0;&#10;    for (int i = 0; i &lt;= k; ++i) {&#10;        ret += comb.C(k, i) * Field{k-i}.pow(n) * (i &amp; 1 ? -1 : 1);&#10;    }&#10;    return ret /= comb.fact(k);&#10;}&#10;" description="stirling" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="matrix" value="&#10;template&lt;typename T&gt;&#10;struct Matrix {&#10;    vector&lt;vector&lt;T&gt;&gt; A;&#10;&#10;    Matrix() {}&#10;&#10;    Matrix(size_t n, size_t m) : A(n, vector&lt;T&gt;(m)) {}&#10;&#10;    Matrix(size_t n) : A(n, vector&lt;T&gt;(n)) {};&#10;&#10;    size_t height() const {&#10;        return (A.size());&#10;    }&#10;&#10;    size_t width() const {&#10;        return (A[0].size());&#10;    }&#10;&#10;    inline const vector&lt;T&gt;&amp; operator[](int k) const {&#10;        return (A.at(k));&#10;    }&#10;&#10;    inline vector&lt;T&gt;&amp; operator[](int k) {&#10;        return (A.at(k));&#10;    }&#10;&#10;    static Matrix I(size_t n) {&#10;        Matrix B(n);&#10;        for (int i = 0; i &lt; n; ++i) B[i][i] = 1;&#10;        return (B);&#10;    }&#10;&#10;    Matrix operator-() const {&#10;        size_t n = height(), m = width();&#10;        Matrix B = *this;&#10;        for (int i = 0; i &lt; n; ++i)&#10;            for (int j = 0; j &lt; m; ++j)&#10;                B[i][j] = -B[i][j];&#10;        return (B);&#10;    }&#10;&#10;    Matrix&amp; operator+=(const Matrix&amp; B) {&#10;        size_t n = height(), m = width();&#10;        assert(n == B.height() and m == B.width());&#10;        for (int i = 0; i &lt; n; ++i)&#10;            for (int j = 0; j &lt; m; ++j)&#10;                A[i][j] += B[i][j];&#10;        return (*this);&#10;    }&#10;&#10;    Matrix&amp; operator-=(const Matrix&amp; B) {&#10;        return (*this += -B);&#10;    }&#10;&#10;    Matrix&amp; operator*=(const Matrix&amp; B) {&#10;        size_t n = height(), m = B.width(), p = width();&#10;        assert(p == B.height());&#10;        Matrix C(n, m);&#10;        for (int i = 0; i &lt; n; ++i)&#10;            for (int j = 0; j &lt; m; ++j)&#10;                for (int k = 0; k &lt; p; ++k)&#10;                    C[i][j] += A[i][k] * B[k][j];&#10;        A.swap(C.A);&#10;        return (*this);&#10;    }&#10;&#10;    Matrix pow(int64_t k) {&#10;        Matrix B = Matrix::I(height()), tmp = *this;&#10;        while (k) {&#10;            if (k &amp; 1) B *= tmp;&#10;            tmp *= tmp; k &gt;&gt;= 1;&#10;        }&#10;        return (B);&#10;    }&#10;&#10;    const Matrix operator+(const Matrix&amp; B) const {&#10;        return (Matrix(*this) += B);&#10;    }&#10;&#10;    const Matrix operator-(const Matrix&amp; B) const {&#10;        return (Matrix(*this) -= B);&#10;    }&#10;&#10;    const Matrix operator*(const Matrix&amp; B) const {&#10;        return (Matrix(*this) *= B);&#10;    }&#10;&#10;    int GaussJordanElimination() {&#10;        int rank = 0;&#10;        for (int col = 0; col &lt; width(); ++col) {&#10;            int pivot = -1;&#10;            for (int row = rank; row &lt; height(); ++row) {&#10;                if (A[row][col] != 0) {&#10;                    pivot = row;&#10;                    break;&#10;                }&#10;            }&#10;            if (pivot == -1) continue;&#10;            swap(A[rank], A[pivot]);&#10;            T topLeft = A[rank][col];&#10;            for (int c = col; c &lt; width(); ++c) {&#10;                A[rank][c] /= topLeft;&#10;            }&#10;            for (int row = rank+1; row &lt; height(); ++row) {&#10;                T ratio = A[row][col];&#10;                for (int c = col; c &lt; width(); ++c)&#10;                    A[row][c] -= ratio * A[rank][c];&#10;            }&#10;            ++rank;&#10;        }&#10;        return (rank);&#10;    }&#10;&#10;    friend istream&amp; operator&gt;&gt;(istream&amp; is, Matrix&amp; B) {&#10;        is &gt;&gt; B.A;&#10;        return (is);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, Matrix&amp; B) {&#10;        size_t n = B.height(), m = B.width();&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            os &lt;&lt; (i == 0 ? &quot;[&quot; : &quot; &quot;);&#10;            for (int j = 0; j &lt; m; ++j) {&#10;                os &lt;&lt; B[i][j] &lt;&lt; (j == m-1 ? &quot;]&quot; : &quot;,&quot;);&#10;            }&#10;            os &lt;&lt; (i == n-1 ? &quot;]\n&quot; : &quot;,\n&quot;);&#10;        }&#10;        return (os);&#10;    }&#10;};&#10;" description="matrix" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="is_prime" value="&#10;// O(sqrt(n))&#10;bool is_prime(int64_t n) {&#10;    assert(n &gt; 0);&#10;    if (n == 1) return false;&#10;    for (int64_t i = 2; i * i &lt;= n; ++i) {&#10;        if (n % i == 0) return false;&#10;    }&#10;    return true;&#10;}&#10;" description="is_prime" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="permutation" value="&#10;struct Permutation {&#10;    vector&lt;int&gt; perm;&#10;    Permutation() {}&#10;    Permutation(int sz) : perm(sz) {&#10;        iota(perm.begin(), perm.end(), 0);&#10;    }&#10;    Permutation(initializer_list&lt;int&gt; init) : perm(init.begin(), init.end()) {}&#10;    size_t size() const {&#10;        return (perm.size());&#10;    }&#10;    inline int operator [](int k) const {&#10;        return (perm.at(k));&#10;    }&#10;    inline int&amp; operator [](int k) {&#10;        return (perm.at(k));&#10;    }&#10;    Permutation&amp; operator*=(const Permutation&amp; rhs) {&#10;        assert(size() == rhs.size());&#10;        Permutation tmp(size());&#10;        for (int i = 0; i &lt; size(); ++i) {&#10;            tmp[i] = perm[rhs[i]];&#10;        }&#10;        perm.swap(tmp.perm);&#10;        return (*this);&#10;    }&#10;    const Permutation operator*(const Permutation&amp; rhs) const {&#10;        return (Permutation(*this) *= rhs);&#10;    }&#10;    Permutation pow(int64_t k) {&#10;        Permutation ret(size()), tmp = *this;&#10;        while (k) {&#10;            if (k &amp; 1) ret *= tmp;&#10;            tmp *= tmp; k &gt;&gt;= 1;&#10;        }&#10;        return (ret);&#10;    }&#10;};&#10;" description="permutation" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="partition" value="&#10;// 分割数&#10;// Partition(k, n) := 区別できないn 個のボールを&#10;//                    区別できないk 個の箱に入れる場合の数&#10;template&lt;typename Ring&gt;&#10;Ring Partition(int k, int n) {&#10;    vector&lt;vector&lt;Ring&gt;&gt; part(k+1, vector&lt;Ring&gt;(n+1));&#10;    part[0][0] = 1;&#10;    for (int i = 1; i &lt;= k; ++i) {&#10;        for (int j = 0; j &lt;= n; ++j) {&#10;            if (j-i &gt;= 0) {&#10;                part[i][j] = part[i-1][j] + part[i][j-i];&#10;            } else {&#10;                part[i][j] = part[i-1][j];&#10;            }&#10;        }&#10;    }&#10;    return part[k][n];&#10;}&#10;" description="partition" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="aho_corasick" value="&#10;template&lt;int char_size, int margin&gt;&#10;struct AhoCorasick {&#10;    Trie&lt;char_size + 1, margin&gt; trie;&#10;    const int FAIL = char_size;&#10;&#10;    AhoCorasick() : trie() {}&#10;&#10;    using Node = typename Trie&lt;char_size + 1, margin&gt;::Node;&#10;&#10;    inline Node operator[](int k) const { return trie[k]; }&#10;    inline Node&amp; operator[](int k) { return trie[k]; }&#10;&#10;    void add(const string&amp; s, int id = 0) {&#10;        trie.add(s, id);&#10;    }&#10;&#10;    void build() {&#10;        queue&lt;int&gt; que;&#10;        for (int i = 0; i &lt; char_size; ++i) {&#10;            if (trie[trie.root].next[i] == -1) {&#10;                trie[trie.root].next[i] = trie.root;&#10;            } else {&#10;                que.push(trie[trie.root].next[i]);&#10;                trie[trie[trie.root].next[i]].next[FAIL] = trie.root;&#10;            }&#10;        }&#10;        while (!que.empty()) {&#10;            int now = que.front(); que.pop();&#10;            for (int i = 0; i &lt; char_size; ++i) {&#10;                if (trie[now].next[i] == -1) continue;&#10;                int fail = trie[now].next[FAIL];&#10;                while (trie[fail].next[i] == -1) {&#10;                    fail = trie[fail].next[FAIL];&#10;                }&#10;                trie[trie[now].next[i]].next[FAIL] = trie[fail].next[i];&#10;                auto &amp;u = trie[trie[now].next[i]].accept;&#10;                auto &amp;v = trie[trie[fail].next[i]].accept;&#10;                vector&lt;int&gt; accept;&#10;                set_union(u.begin(), u.end(), v.begin(), v.end(),&#10;                        back_inserter(accept));&#10;                u = accept;&#10;                que.push(trie[now].next[i]);&#10;            }&#10;        }&#10;    }&#10;&#10;    map&lt;int,int&gt; match(const string&amp; str) const {&#10;        map&lt;int,int&gt; ret;&#10;        int now = trie.root;&#10;        for (char c : str) {&#10;            while (trie[now].next[c - margin] == -1) now = trie[now].next[FAIL];&#10;            now = trie[now].next[c - margin];&#10;            for (int id : trie[now].accept) ++ret[id];&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const AhoCorasick&amp; aho) {&#10;        const int n = aho.trie.nodes.size();&#10;        vector&lt;bool&gt; used(n);&#10;        function&lt;void(int)&gt; dfs = [&amp;](int now) {&#10;            used[now] = true;&#10;            os &lt;&lt; &quot;{&quot; &lt;&lt; now &lt;&lt; &quot; &quot; &lt;&lt; &quot;#:&quot; &lt;&lt; aho[now].next[aho.FAIL];&#10;            for (int i = 0; i &lt; char_size; ++i) {&#10;                int nxt = aho[now].next[i];&#10;                if (nxt != -1) {&#10;                    os &lt;&lt; &quot;, &quot; &lt;&lt; (char)(i + margin) &lt;&lt; &quot;:&quot;;&#10;                    if (!used[nxt]) dfs(nxt);&#10;                    else os &lt;&lt; nxt;&#10;                }&#10;            }&#10;&#10;            os &lt;&lt; &quot;}&quot;;&#10;        };&#10;        dfs(aho.trie.root);&#10;        return os;&#10;    }&#10;};&#10;" description="aho_corasick" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rolling_hash" value="&#10;struct RollingHash {&#10;    using uint = uint64_t;&#10;    vector&lt;uint&gt; hash, pow;&#10;    static const uint MASK30 = (1LL&lt;&lt;30)-1,&#10;                      MASK31 = (1LL&lt;&lt;31)-1,&#10;                      MASK61 = (1LL&lt;&lt;61)-1;&#10;&#10;    template&lt;typename S&gt;&#10;    RollingHash(const S&amp; s, uint base) {&#10;        int n = s.size();&#10;        hash.assign(n+1, 0);&#10;        pow.assign(n+1, 1);&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            hash[i+1] = _mod(_mul(hash[i], base) + s[i]);&#10;            pow[i+1] = _mul(pow[i], base);&#10;        }&#10;    }&#10;&#10;    uint get(int l, int r) const {&#10;        return _mod(hash[r] + MASK61 - _mul(hash[l], pow[r - l]));&#10;    }&#10;&#10;    static uint _mul(uint a, uint b) {&#10;        uint au = a &gt;&gt; 31, ad = a &amp; MASK31,&#10;             bu = b &gt;&gt; 31, bd = b &amp; MASK31;&#10;        uint m = au * bd + ad * bu;&#10;        uint mu = m &gt;&gt; 30, md = m &amp; MASK30;&#10;&#10;        return _mod(au*bu*2 + mu + (md&lt;&lt;31) + ad*bd);&#10;    }&#10;    static uint _mod(uint x) {&#10;        uint xu = x &gt;&gt; 61, xd = x &amp; MASK61;&#10;        uint ret = xu + xd;&#10;        if (ret &gt;= MASK61) ret -= MASK61;&#10;        return ret;&#10;    }&#10;    static uint gen_base() {&#10;        mt19937 random{random_device{}()};&#10;        uniform_int_distribution&lt;uint&gt; dist(2, MASK61-2);&#10;        return dist(random);&#10;    }&#10;};&#10;" description="rolling_hash" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="trie" value="&#10;template&lt;int char_size, int margin&gt;&#10;struct Trie {&#10;    struct Node {&#10;        vector&lt;int&gt; next, accept;&#10;        Node() : next(char_size, -1) {}&#10;    };&#10;&#10;    vector&lt;Node&gt; nodes;&#10;    int root;&#10;    Trie() : root(0) { nodes.push_back(Node()); }&#10;&#10;    inline Node operator[](int k) const { return nodes[k]; }&#10;    inline Node&amp; operator[](int k) { return nodes[k]; }&#10;&#10;    void add(const string&amp; s, int id = 0) {&#10;        int now = root;&#10;        for (char c : s) {&#10;            if (nodes[now].next[c - margin] == -1) {&#10;                nodes[now].next[c - margin] = nodes.size();&#10;                nodes.push_back(Node());&#10;            }&#10;            now = nodes[now].next[c - margin];&#10;        }&#10;        nodes[now].accept.push_back(id);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Trie&amp; trie) {&#10;        function&lt;void(int)&gt; dfs = [&amp;](int now) {&#10;            os &lt;&lt; &quot;{&quot;;&#10;            bool a = 0;&#10;            for (int i = 0; i &lt; char_size; ++i) {&#10;                int nxt = trie[now].next[i];&#10;                if (nxt != -1) {&#10;                    if (a) os &lt;&lt; &quot;, &quot;; a = 1;&#10;                    os &lt;&lt; (char)(i + margin) &lt;&lt; &quot;: &quot;;&#10;                    dfs(nxt);&#10;                }&#10;            }&#10;            os &lt;&lt; &quot;}&quot;;&#10;        };&#10;        dfs(trie.root);&#10;        return os;&#10;    }&#10;&#10;};&#10;" description="trie" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistent_segment_tree" value="&#10;template&lt;typename M&gt;&#10;struct PersistentSegmentTree {&#10;    struct Node {&#10;        Node *l, *r;&#10;        M data;&#10;        Node() : l(nullptr), r(nullptr) {}&#10;    };&#10;&#10;    const function&lt;M(M,M)&gt; f;&#10;    const M e;&#10;    const int sz;&#10;&#10;    PersistentSegmentTree(const function&lt;M(M,M)&gt;&amp; f, const M&amp; e, int sz) :&#10;        f(f), e(e), sz(sz) {}&#10;&#10;    Node* _new(const M&amp; data) const {&#10;        auto t = new Node();&#10;        t-&gt;data = data;&#10;        return t;&#10;    }&#10;&#10;    Node* _new(Node* l, Node* r) const {&#10;        auto t = new Node();&#10;        t-&gt;l = l, t-&gt;r = r, t-&gt;data = f(l-&gt;data, r-&gt;data);&#10;        return t;&#10;    }&#10;&#10;    Node* _build(int l, int r) const {&#10;        assert(l &lt; r);&#10;        if (l+1 == r) return _new(e);&#10;        return _new(_build(l, (l+r)&gt;&gt;1), _build((l+r)&gt;&gt;1, r));&#10;    }&#10;&#10;    Node* build() const {&#10;        return _build(0, sz);&#10;    }&#10;&#10;    template&lt;typename UpdateQuery&gt;&#10;    Node* _update(Node* t, const UpdateQuery&amp; q, int pos, int l, int r) const {&#10;        if (pos == l and pos+1 == r) return _new(q(t-&gt;data));&#10;        if (r &lt;= pos or pos &lt; l) return t;&#10;        return _new(_update(t-&gt;l, q, pos, l, (l+r)&gt;&gt;1),&#10;                    _update(t-&gt;r, q, pos, (l+r)&gt;&gt;1, r));&#10;    }&#10;&#10;    template&lt;typename UpdateQuery&gt;&#10;    Node* update(Node* root, int pos, const UpdateQuery&amp; q) const {&#10;        return _update(root, q, pos, 0, sz);&#10;    }&#10;&#10;    M _query(Node* t, int a, int b, int l, int r) const {&#10;        if (r &lt;= a or b &lt;= l) return e;&#10;        if (a &lt;= l and r &lt;= b) return t-&gt;data;&#10;        return f(_query(t-&gt;l, a, b, l, (l+r)&gt;&gt;1),&#10;                 _query(t-&gt;r, a, b, (l+r)&gt;&gt;1, r));&#10;    }&#10;&#10;    M query(Node* root, int a, int b) const {&#10;        // return f[a,b)&#10;        return _query(root, a, b, 0, sz);&#10;    }&#10;&#10;};&#10;" description="persistent_segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazy_randomized_binary_search_tree" value="&#10;template&lt;typename M, typename OM = M&gt;&#10;struct LazyRandomizedBinarySearchTree {&#10;&#10;    struct Node {&#10;        Node *lch, *rch;&#10;        int sz;&#10;        M data, sum;&#10;        OM lazy;&#10;        Node(const M&amp; data, const OM&amp; lazy) :&#10;            lch(nullptr), rch(nullptr), sz(1),&#10;            data(data), sum(data), lazy(lazy) {}&#10;    };&#10;&#10;    const function&lt;M(M,M)&gt; f;&#10;    const function&lt;M(M,OM,int)&gt; g;&#10;    const function&lt;OM(OM,OM)&gt; h;&#10;    const M e;&#10;    const OM oe;&#10;    Node* root;&#10;    std::mt19937 random{std::random_device{}()};&#10;&#10;    LazyRandomizedBinarySearchTree(&#10;            const function&lt;M(M,M)&gt;&amp; f,&#10;            const function&lt;M(M,OM,int)&gt;&amp; g,&#10;            const function&lt;OM(OM,OM)&gt;&amp; h,&#10;            const M&amp; e, const OM&amp; oe&#10;            ) : f(f), g(g), h(h), e(e), oe(oe), root(nullptr) {}&#10;&#10;    Node* _build(const vector&lt;M&gt;&amp; v, int l, int r) {&#10;        if (l+1 &gt;= r) return _new(v[l]);&#10;        return merge(_build(v, l, (l+r)&gt;&gt;1),&#10;                     _build(v, (l+r)&gt;&gt;1, r));&#10;    }&#10;    void build(const vector&lt;M&gt;&amp; v) { root = _build(v, 0, v.size()); }&#10;&#10;    Node* _build(int l, int r) {&#10;        if (l+1 &gt;= r) return _new(e);&#10;        return merge(_build(l, (l+r)&gt;&gt;1),&#10;                     _build((l+r)&gt;&gt;1, r));&#10;    }&#10;    void build(int size) { root = _build(0, size); }&#10;&#10;    inline Node* _new(const M&amp; data) const { return new Node(data, oe); }&#10;&#10;    inline int size(Node* t) const { return t ? t-&gt;sz : 0; }&#10;    inline M sum(Node* t) const { return t ? t-&gt;sum : e; }&#10;    inline OM lazy(Node* t) const { return t ? t-&gt;lazy : oe; }&#10;&#10;    inline Node* modify(Node *t) {&#10;        t-&gt;sz = size(t-&gt;lch) + size(t-&gt;rch) + 1;&#10;        t-&gt;sum = f(f(sum(t-&gt;lch), t-&gt;data), sum(t-&gt;rch));&#10;        return t;&#10;    }&#10;&#10;    // Lazy Segment Tree&#10;    Node* propagate(Node* t) {&#10;        if (!t) return t;&#10;        if (lazy(t) == oe) return t;&#10;        if (t-&gt;lch != nullptr) {&#10;            t-&gt;lch-&gt;lazy = h(lazy(t-&gt;lch), lazy(t));&#10;            t-&gt;lch-&gt;sum = g(sum(t-&gt;lch), lazy(t), size(t-&gt;lch));&#10;        }&#10;        if (t-&gt;rch != nullptr) {&#10;            t-&gt;rch-&gt;lazy = h(lazy(t-&gt;rch), lazy(t));&#10;            t-&gt;rch-&gt;sum = g(sum(t-&gt;rch), lazy(t), size(t-&gt;rch));&#10;        }&#10;        t-&gt;data = g(t-&gt;data, lazy(t), 1);&#10;        t-&gt;lazy = oe;&#10;        return modify(t);&#10;    }&#10;&#10;    void update(int a, int b, const OM&amp; lazy) {&#10;        // data[a, b) = g(data[a, b), lazy)&#10;        auto p0 = split(root, a);&#10;        auto p1 = split(p0.second, b-a);&#10;        p1.first-&gt;lazy = h(p1.first-&gt;lazy, lazy);&#10;        p1.first = propagate(p1.first);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;    }&#10;&#10;    M query(int a, int b) {&#10;        // return f[a,b)&#10;        auto p0 = split(root, a);&#10;        auto p1 = split(p0.second, b-a);&#10;        p1.first = propagate(p1.first);&#10;        M ret = sum(p1.first);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;        return ret;&#10;    }&#10;&#10;&#10;    // Binary Search Tree&#10;    Node* merge(Node *l, Node *r) {&#10;        if (!l) return r;&#10;        if (!r) return l;&#10;        std::uniform_int_distribution&lt;&gt; dist(1,size(l)+size(r));&#10;        if (dist(random) &gt; size(l)) {&#10;            r = propagate(r);&#10;            r-&gt;lch = merge(l, r-&gt;lch);&#10;            return modify(r);&#10;        } else {&#10;            l = propagate(l);&#10;            l-&gt;rch = merge(l-&gt;rch, r);&#10;            return modify(l);&#10;        }&#10;    }&#10;&#10;    pair&lt;Node*, Node*&gt; split(Node* t, int k) {&#10;        if (!t) return {t, t};&#10;        t = propagate(t);&#10;        if (k &gt; size(t-&gt;lch)) {&#10;            auto p = split(t-&gt;rch, k-size(t-&gt;lch)-1);&#10;            t-&gt;rch = p.first;&#10;            return {modify(t), p.second};&#10;        } else {&#10;            auto p = split(t-&gt;lch, k);&#10;            t-&gt;lch = p.second;&#10;            return {p.first, modify(t)};&#10;        }&#10;    }&#10;&#10;    void insert(int k, const M&amp; data) {&#10;        auto q = _new(data);&#10;        auto p = split(root, k);&#10;        root = merge(merge(p.first, q), p.second);&#10;    }&#10;&#10;    M erase(int k) {&#10;        auto p = split(root, k);&#10;        auto q = split(p.second, 1);&#10;        M ret = q.first-&gt;data;&#10;        root = merge(p.first, q.second);&#10;        return ret;&#10;    }&#10;&#10;    M operator[](int i) {&#10;        return query(i, i+1);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,&#10;            LazyRandomizedBinarySearchTree&amp; tr) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; tr.root-&gt;sz; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; tr[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;};&#10;" description="lazy_randomized_binary_search_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binary_indexed_tree" value="&#10;template&lt;typename T&gt;&#10;struct BIT {&#10;    vector&lt;T&gt; data;&#10;    int sz;&#10;    BIT(int sz) : sz(sz), data(sz+1) {}&#10;&#10;    void add(int i, T x) {&#10;        // v[i] += x;&#10;        assert(0 &lt;= i and i &lt; sz);&#10;        for (++i; i &lt; data.size(); i += i &amp; -i) data[i] += x;&#10;    }&#10;&#10;    T sum(int i) const {&#10;        // return v[0] + v[1] + ... + v[i]&#10;        if (i &lt; 0) return 0;&#10;        assert(i &lt; sz);&#10;        T s = 0;&#10;        for (++i; i &gt; 0; i -= i &amp; -i) s += data[i];&#10;        return s;&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const BIT&amp; b) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; b.sz; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; b.sum(i) - b.sum(i-1);&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;};&#10;" description="binary_indexed_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="weighted_union_find" value="&#10;template&lt;typename A&gt;&#10;struct WeightedUnionFind&#10;{&#10;    vector&lt;int&gt; par, sz;&#10;    vector&lt;A&gt; data;     // data[x]: diff from root to x&#10;    WeightedUnionFind(int n, A e=0) :&#10;        par(n), sz(n, 1), data(n, e) {&#10;        for (int i = 0; i &lt; n; ++i) par[i] = i;&#10;    }&#10;&#10;    int root(int x) {&#10;        if (par[x] == x) return x;&#10;        int r = root(par[x]);&#10;        data[x] += data[par[x]];&#10;        return par[x] = r;&#10;    }&#10;&#10;    A weight(int x) {&#10;        root(x);&#10;        return data[x];&#10;    }&#10;&#10;    A diff(int x, int y) {&#10;        // diff from x to y&#10;        return data[y] - data[x];&#10;    }&#10;&#10;    void merge(int x, int y, A w) {&#10;        // merge so that &quot;diff from x to y&quot; will be w.&#10;        w += weight(x); w -= weight(y);&#10;        x = root(x); y = root(y);&#10;        if (x == y) return;&#10;        if (sz[x] &lt; sz[y]) swap(x, y), w = -w;&#10;        par[y] = x;&#10;        sz[x] += sz[y];&#10;        sz[y] = 0;&#10;        data[y] = w;&#10;    }&#10;&#10;    bool issame(int x, int y) {&#10;        return root(x) == root(y);&#10;    }&#10;};&#10;" description="weighted_union_find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="union_find" value="&#10;struct UnionFind&#10;{&#10;    const int n;&#10;    vector&lt;int&gt; par, sz;&#10;    UnionFind(int n) : n(n), par(n), sz(n, 1) {&#10;        for (int i = 0; i &lt; n; ++i) par[i] = i;&#10;    }&#10;&#10;    int root(int x) {&#10;        if (par[x] == x) return x;&#10;        return par[x] = root(par[x]);&#10;    }&#10;&#10;    void merge(int x, int y) {&#10;        x = root(x);&#10;        y = root(y);&#10;        if (x == y) return;&#10;        if (sz[x] &lt; sz[y]) swap(x, y);&#10;        par[y] = x;&#10;        sz[x] += sz[y];&#10;        sz[y] = 0;&#10;    }&#10;&#10;    bool issame(int x, int y) {&#10;        return root(x) == root(y);&#10;    }&#10;&#10;    int size(int x) {&#10;        return sz[root(x)];&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, UnionFind&amp; uf) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; uf.n; ++i) {&#10;            if (i &gt; 0) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; uf.root(i);&#10;        }&#10;        return os &lt;&lt; &quot;]&quot; &lt;&lt; endl;&#10;    }&#10;};&#10;" description="union_find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazy_segment_tree" value="&#10;template&lt;typename M, typename OM = M&gt;&#10;struct LazySegmentTree {&#10;&#10;    LazySegmentTree(&#10;            int n,&#10;            const function&lt;M(M,M)&gt;&amp; f,&#10;            const function&lt;M(M,OM,int)&gt;&amp; g,&#10;            const function&lt;OM(OM,OM)&gt;&amp; h,&#10;            const M&amp; e, const OM&amp; oe&#10;            ) : n(n), f(f), g(g), h(h), e(e), oe(oe) {&#10;        sz = 1;&#10;        while (sz &lt; n) sz &lt;&lt;= 1;&#10;        data.assign(2*sz, e);&#10;        lazy.assign(2*sz, oe);&#10;    }&#10;&#10;    void build(const vector&lt;M&gt;&amp; v) {&#10;        assert(v.size() &lt;= n);&#10;        for (int i = 0; i &lt; v.size(); ++i) {&#10;            data[i + sz] = v[i];&#10;        }&#10;        for (int i = sz-1; i &gt; 0; --i) {&#10;            data[i] = f(data[2*i], data[2*i+1]);&#10;        }&#10;    }&#10;&#10;    void update(int a, int b, const OM&amp; x) {&#10;        // update [a, b) with x.&#10;        update(a, b, x, 1, 0, sz);&#10;    }&#10;&#10;&#10;    M query(int a, int b) {&#10;        // return f[a, b).&#10;        return query(a, b, 1, 0, sz);&#10;    }&#10;&#10;    M operator[](int i) {&#10;        return query(i, i+1);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, LazySegmentTree&amp; s) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; s.n; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; s[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;&#10;private:&#10;&#10;    int n, sz;&#10;    vector&lt;M&gt; data;&#10;    vector&lt;OM&gt; lazy;&#10;    const function&lt;M(M,M)&gt; f;&#10;    const function&lt;M(M,OM,int)&gt; g;&#10;    const function&lt;OM(OM,OM)&gt; h;&#10;    const M e;&#10;    const OM oe;&#10;    // f: 二つの区間の要素をマージする関数&#10;    // g: 要素と作用素をマージする二項演算. 第三引数は区間幅&#10;    // h: 作用素をマージする関数&#10;    // e: モノイドの単位元&#10;    // oe: 作用素の単位元&#10;&#10;    void propagate(int k, int len) {&#10;        if (lazy[k] == oe) return;&#10;        if (k &lt; sz) {&#10;            lazy[2*k  ] = h(lazy[2*k  ], lazy[k]);&#10;            lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);&#10;        }&#10;        data[k] = g(data[k], lazy[k], len);&#10;        lazy[k] = oe;&#10;    }&#10;&#10;    void update(int a, int b, const OM&amp; x, int k, int l, int r) {&#10;        propagate(k, r - l);&#10;        if (r &lt;= a or b &lt;= l) return;&#10;        else if (a &lt;= l and r &lt;= b) {&#10;            lazy[k] = h(lazy[k], x);&#10;            propagate(k, r - l);&#10;        } else {&#10;            update(a, b, x, 2*k,   l, (l+r)/2);&#10;            update(a, b, x, 2*k+1, (l+r)/2, r);&#10;            data[k] = f(data[2*k], data[2*k+1]);&#10;        }&#10;    }&#10;&#10;    M query(int a, int b, int k, int l, int r) {&#10;        propagate(k, r - l);&#10;        if (r &lt;= a or b &lt;= l) return e;&#10;        else if (a &lt;= l and r &lt;= b) return data[k];&#10;        else return f(&#10;                query(a, b, 2*k,   l, (l+r)/2),&#10;                query(a, b, 2*k+1, (l+r)/2, r));&#10;    }&#10;};&#10;" description="lazy_segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segment_tree" value="&#10;template&lt;typename M&gt;&#10;struct SegmentTree {&#10;    int n, sz;&#10;    vector&lt;M&gt; data;&#10;    const function&lt;M(M,M)&gt; f;&#10;    const M e;&#10;&#10;    SegmentTree(&#10;            int n,&#10;            const function&lt;M(M,M)&gt;&amp; f,&#10;            const M&amp; e&#10;            ) : n(n), f(f), e(e) {&#10;        sz = 1;&#10;        while (sz &lt; n) sz &lt;&lt;= 1;&#10;        data.assign(2*sz, e);&#10;    }&#10;&#10;    void build(const vector&lt;M&gt;&amp; v) {&#10;        assert(v.size() &lt;= n);&#10;        for (int i = 0; i &lt; v.size(); ++i) {&#10;            data[i + sz] = v[i];&#10;        }&#10;        for (int i = sz-1; i &gt; 0; --i) {&#10;            data[i] = f(data[2*i], data[2*i+1]);&#10;        }&#10;    }&#10;&#10;    template&lt;typename UpdateQuery&gt;&#10;    void update(int k, const UpdateQuery&amp; q) {&#10;        k += sz;&#10;        data[k] = q(data[k]);&#10;        while (k &gt;&gt;= 1) {&#10;            data[k] = f(data[2*k], data[2*k+1]);&#10;        }&#10;    }&#10;&#10;    M _query(int a, int b, int k, int l, int r) const {&#10;        if (r &lt;= a or b &lt;= l) return e;&#10;        if (a &lt;= l and r &lt;= b) return data[k];&#10;        return f(_query(a,b,2*k,  l,(l+r)/2),&#10;                 _query(a,b,2*k+1,(l+r)/2,r));&#10;    }&#10;&#10;    M query(int a, int b) const {&#10;        // return f[a,b)&#10;        return _query(a, b, 1, 0, sz);&#10;    }&#10;&#10;    M operator[](int i) const {&#10;        return data.at(i + sz);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const SegmentTree&amp; s) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; s.n; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; s[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;};&#10;" description="segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dual_segment_tree" value="&#10;template&lt;typename OM&gt;&#10;struct DualSegmentTree {&#10;    int n, sz;&#10;    vector&lt;OM&gt; lazy;&#10;    const function&lt;OM(OM,OM)&gt; h;&#10;    const OM oe;&#10;    // h: 作用素をマージする関数&#10;    // oe: 作用素の単位元&#10;&#10;    DualSegmentTree(&#10;            int n,&#10;            const function&lt;OM(OM,OM)&gt;&amp; h,&#10;            const OM&amp; oe&#10;            ) : n(n), h(h), oe(oe) {&#10;        sz = 1;&#10;        while (sz &lt; n) sz &lt;&lt;= 1;&#10;        lazy.assign(2*sz, oe);&#10;    }&#10;&#10;    void set(int i, const OM&amp; x) {&#10;        lazy.at(i + sz) = x;&#10;    }&#10;&#10;    OM merge(const OM&amp; a, const OM&amp; b) const {&#10;        if (a == oe) return b;&#10;        if (b == oe) return a;&#10;        return h(a, b);&#10;    }&#10;&#10;    void propagate(int k, int len) {&#10;        if (lazy[k] == oe) return;&#10;        if (k &lt; sz) {&#10;            lazy[2*k  ] = merge(lazy[2*k  ], lazy[k]);&#10;            lazy[2*k+1] = merge(lazy[2*k+1], lazy[k]);&#10;            lazy[k] = oe;&#10;        }&#10;    }&#10;&#10;    void _update(int a, int b, const OM&amp; x, int k, int l, int r) {&#10;        propagate(k, r - l);&#10;        if (r &lt;= a or b &lt;= l) return;&#10;        else if (a &lt;= l and r &lt;= b) {&#10;            lazy[k] = merge(lazy[k], x);&#10;            propagate(k, r - l);&#10;        } else {&#10;            _update(a, b, x, 2*k,   l, (l+r)/2);&#10;            _update(a, b, x, 2*k+1, (l+r)/2, r);&#10;        }&#10;    }&#10;&#10;    void update(int a, int b, const OM&amp; x) {&#10;        // update [a, b) with x.&#10;        _update(a, b, x, 1, 0, sz);&#10;    }&#10;&#10;    OM _query(int i, int k, int l, int r) {&#10;        if (l+1 == r) return lazy[l + sz];&#10;        propagate(k, r - l);&#10;        int m = (l+r)/2;&#10;        if (i &lt; m) return _query(i, 2*k,   l, m);&#10;        else       return _query(i, 2*k+1, m, r);&#10;    }&#10;&#10;    OM operator[](int i) {&#10;        return _query(i, 1, 0, sz);&#10;    }&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, DualSegmentTree&amp; s) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; s.n; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; s[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;};&#10;" description="dual_segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>
